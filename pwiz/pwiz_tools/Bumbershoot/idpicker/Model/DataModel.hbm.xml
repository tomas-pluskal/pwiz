<?xml version="1.0" encoding="utf-8" ?>
<!--
//
// $Id$
//
// The contents of this file are subject to the Mozilla Public License
// Version 1.1 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an "AS IS"
// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
// License for the specific language governing rights and limitations
// under the License.
//
// The Original Code is the IDPicker project.
//
// The Initial Developer of the Original Code is Matt Chambers.
//
// Copyright 2010 Vanderbilt University
//
// Contributor(s): Surendra Dasari
//
-->
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" namespace="IDPicker.DataModel" assembly="IDPicker.DataModel" auto-import="true">

	<class name="SpectrumSourceGroup">
		<id name="Id"><generator class="native"/></id>
		<property name="Name"/>
		<set name="Sources" inverse="true" batch-size="500" lazy="true">
			<key column="Group_"/>
			<one-to-many class="SpectrumSourceGroupLink"/>
		</set>
	</class>

	<class name="SpectrumSource">
		<id name="Id"><generator class="native"/></id>
		<property name="Name"/>
		<property name="URL"/>
		<many-to-one name="Group" column="Group_" fetch="join"/>
		<set name="Groups" inverse="true" batch-size="500">
			<key column="Source" />
			<one-to-many class="SpectrumSourceGroupLink"/>
		</set>
		<bag name="Spectra" inverse="true" batch-size="500">
			<key column="Source"/>
			<one-to-many class="Spectrum"/>
		</bag>
		<property name="Metadata" column="MsDataBytes" lazy="true" type="SpectrumSourceMetadataUserType"/>
	</class>

	<class name="SpectrumSourceGroupLink">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="Source" fetch="join"/>
		<many-to-one name="Group" column="Group_" fetch="join"/>
	</class>
		   
	<class name="Spectrum">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="Source" fetch="join"/>
		<property name="Index" column="Index_"/>
		<property name="NativeID"/>
		<property name="PrecursorMZ"/>
		<bag name="Matches" inverse="true" batch-size="500" lazy="true">
			<key column="Spectrum"/>
			<one-to-many class="PeptideSpectrumMatch"/>
		</bag>
		<!--<property name="Peaks" lazy="true" type="SpectrumPeakListUserType"/>-->
	</class>

	<class name="AnalysisParameter">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="Analysis" fetch="join"/>
		<property name="Name"/>
		<property name="Value"/>
	</class>

	<class name="Analysis">
		<id name="Id"><generator class="native"/></id>
		<property name="Name"/>
		<component name="Software">
			<property name="Name" column="SoftwareName"/>
			<property name="Version" column="SoftwareVersion"/>
		</component>
		<property name="Type"/>
		<property name="StartTime" type="UtcDateTime"/>
		<set name="Parameters" inverse="true" batch-size="50">
			<key column="Analysis"/>
			<one-to-many class="AnalysisParameter"/>
		</set>
		<bag name="Matches" inverse="true" batch-size="500" lazy="true">
			<key column="Analysis"/>
			<one-to-many class="PeptideSpectrumMatch"/>
		</bag>
	</class>

	<class name="Protein">
		<id name="Id"><generator class="native"/></id>
		<property name="Accession" />

		<!-- We store these long text fields in separate tables so that joins against the Proteins table are faster -->
		<property name="Description" formula="(SELECT pmd.Description FROM ProteinMetadata pmd WHERE Id=pmd.Id)"/>
		<property name="Sequence" lazy="true" formula="(SELECT pd.Sequence FROM ProteinData pd WHERE Id=pd.Id)"/>


		<bag name="Peptides" inverse="true" batch-size="500" lazy="true">
			<key column="Protein"/>
			<one-to-many class="PeptideInstance"/>
		</bag>
		<property name="Cluster" access="nosetter.camelcase"/>
		<property name="ProteinGroup" access="nosetter.camelcase"/>
		<property name="Length" access="nosetter.camelcase"/>

		<property name="Coverage" formula="(SELECT pc.Coverage FROM ProteinCoverage pc WHERE Id=pc.Id)"/>
		<property name="CoverageMask" formula="(SELECT pc.CoverageMask FROM ProteinCoverage pc WHERE Id=pc.Id)" type="ProteinCoverageMaskUserType"/>

		<one-to-one name="pmd"/>
		<one-to-one name="pd"/>
		<one-to-one name="pc"/>
	</class>

	<class name="ProteinMetadata"><id name="Id"><generator class="native"/></id><property name="Description"/></class>
	<class name="ProteinData"><id name="Id"><generator class="native"/></id><property name="Sequence"/></class>
	<class name="ProteinCoverage"><id name="Id"><generator class="native"/></id><property name="Coverage"/><property name="CoverageMask" type="ProteinCoverageMaskUserType"/></class>

	<class name="Peptide">
		<id name="Id"><generator class="native"/></id>
		<property name="Sequence" access="nosetter.camelcase" 
				  formula="(SELECT SUBSTR(pro.Sequence, pi.Offset+1, pi.Length)
							FROM PeptideInstance pi
							JOIN ProteinData pro ON pi.Protein=pro.Id
							WHERE pi.Protein=pro.Id AND
							  pi.Id=(SELECT MIN(pi2.Id)
									 FROM PeptideInstance pi2
									 WHERE Id=pi2.Peptide))"/>
		<property name="MonoisotopicMass"/>
		<property name="MolecularWeight"/>
		<bag name="Instances" inverse="true" batch-size="500" lazy="true">
			<key column="Peptide"/>
			<one-to-many class="PeptideInstance"/>
		</bag>
		<bag name="Matches" inverse="true" batch-size="500" lazy="true">
			<key column="Peptide"/>
			<one-to-many class="PeptideSpectrumMatch"/>
		</bag>
	</class>

	<class name="PeptideInstance">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="Protein" fetch="join"/>
		<many-to-one name="Peptide" fetch="join"/>
		<property name="Offset"/>
		<property name="Length"/>
		<property name="NTerminusIsSpecific"/>
		<property name="CTerminusIsSpecific"/>
		<property name="MissedCleavages"/>
		<property name="SpecificTermini" access="nosetter.camelcase" formula="(SELECT NTerminusIsSpecific + CTerminusIsSpecific)"/>
	</class>

	<class name="Modification">
		<id name="Id"><generator class="native"/></id>
		<property name="MonoMassDelta"/>
		<property name="AvgMassDelta"/>
		<property name="Formula"/>
		<property name="Name"/>
	</class>

	<class name="PeptideSpectrumMatch">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="Spectrum" fetch="join"/>
		<many-to-one name="Analysis" fetch="join"/>
		<many-to-one name="Peptide" fetch="join"/>
		<bag name="Modifications" inverse="true" batch-size="500" lazy="true">
			<key column="PeptideSpectrumMatch"/>
			<one-to-many class="PeptideModification"/>
		</bag>
		<property name="QValue">
			<column name="QValue" sql-type="DOUBLE"/>
		</property>
		<property name="MonoisotopicMass"/>
		<property name="MolecularWeight"/>
		<property name="MonoisotopicMassError"/>
		<property name="MolecularWeightError"/>
		<property name="Rank"/>
		<property name="Charge"/>
		<map name="Scores" table="PeptideSpectrumMatchScore">
			<key column="Id">
				<column name="PsmId"/>
			</key>
			<index column="Name" type="String">
				<column name="ScoreNameId" sql-type="integer"/>
			</index>
			<element column="Value" type="Double"/>
			<loader query-ref="PeptideSpectrumMatchScores_LoaderQuery"/>
			<!--<sql-insert check="none">
				CREATE TEMP TABLE PsmScore AS SELECT ? AS PsmId, ? AS Name, ? AS Value;

				INSERT OR IGNORE INTO PeptideSpectrumMatchScoreNames (Id, Name)
				VALUES ((SELECT IFNULL(MAX(Id)+1, 1) FROM PeptideSpectrumMatchScoreNames),
						(SELECT Name FROM PsmScore LIMIT 1));

				INSERT INTO PeptideSpectrumMatchScores (PsmId, ScoreNameId, Value)
				VALUES ((SELECT PsmId FROM PsmScore LIMIT 1),
						(SELECT Id FROM PeptideSpectrumMatchScoreNames WHERE Name=(SELECT Name FROM PsmScore LIMIT 1)),
						(SELECT Value FROM PsmScore LIMIT 1));
				DROP TABLE PsmScore
			</sql-insert>-->
		</map>
		<property name="FullDistinctKey" access="nosetter.camelcase" formula="(Peptide || ' ' || MonoisotopicMass || ' ' || Charge)"/>
		<property name="SequenceAndMassDistinctKey" access="nosetter.camelcase" formula="(Peptide || ' ' || IFNULL((SELECT GROUP_CONCAT(pm.Modification || '@' || pm.Offset) FROM PeptideModification pm WHERE Id=pm.PeptideSpectrumMatch), ''))"/>
	</class>

	<class name="PeptideModification">
		<id name="Id"><generator class="native"/></id>
		<many-to-one name="PeptideSpectrumMatch" fetch="join"/>
		<many-to-one name="Modification" fetch="join"/>
		<property name="Offset" access="nosetter.camelcase"/>
		<property name="Site" access="nosetter.camelcase"/>
		<!--An index on the Site property seems to override the PSM index :( index="PeptideModification_Site"-->
	</class>

  <sql-query read-only="true" name="PeptideSpectrumMatchScores_LoaderQuery">
		<load-collection alias="scores" role="PeptideSpectrumMatch.Scores"/>
		SELECT {scores.*}
		FROM (	SELECT PsmId, Name AS ScoreNameId, Value
				FROM PeptideSpectrumMatchScore
				JOIN PeptideSpectrumMatchScoreName ON ScoreNameId = Id
				WHERE PsmId = ?
			 ) scores
	</sql-query>

</hibernate-mapping>
