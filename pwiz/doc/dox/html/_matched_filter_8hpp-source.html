<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ProteoWizard: /stf/home/atrium/darren/sf_pwiz/pwiz/utility/math/MatchedFilter.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>/stf/home/atrium/darren/sf_pwiz/pwiz/utility/math/MatchedFilter.hpp</h1><a href="_matched_filter_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">// MatchedFilter.hpp</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Original author: Darren Kessner &lt;Darren.Kessner@cshs.org&gt;</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// Copyright 2007 Spielberg Family Center for Applied Proteomics </span>
<a name="l00008"></a>00008 <span class="comment">//   Cedars Sinai Medical Center, Los Angeles, California  90048</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// Licensed under the Apache License, Version 2.0 (the "License"); </span>
<a name="l00011"></a>00011 <span class="comment">// you may not use this file except in compliance with the License. </span>
<a name="l00012"></a>00012 <span class="comment">// You may obtain a copy of the License at </span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// Unless required by applicable law or agreed to in writing, software </span>
<a name="l00017"></a>00017 <span class="comment">// distributed under the License is distributed on an "AS IS" BASIS, </span>
<a name="l00018"></a>00018 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </span>
<a name="l00019"></a>00019 <span class="comment">// See the License for the specific language governing permissions and </span>
<a name="l00020"></a>00020 <span class="comment">// limitations under the License.</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#ifndef _MATCHEDFILTER_HPP_</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#define _MATCHEDFILTER_HPP_</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include "<a class="code" href="round_8hpp.html">utility/math/round.hpp</a>"</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">namespace </span>pwiz {
<a name="l00038"></a>00038 <span class="keyword">namespace </span>math {
<a name="l00039"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html">00039</a> <span class="keyword">namespace </span>MatchedFilter {
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;
<a name="l00043"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">00043</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">ProductSpace</a>
<a name="l00044"></a>00044 {
<a name="l00045"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html#7388eca8c24f7207624dc5eab887d607">00045</a>     <span class="keyword">typedef</span> X <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html#7388eca8c24f7207624dc5eab887d607">abscissa_type</a>;
<a name="l00046"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html#6cabcba477246b70e7f7380510c1b130">00046</a>     <span class="keyword">typedef</span> <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940de5da2374173efa519482c866a5043a00">Y</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html#6cabcba477246b70e7f7380510c1b130">ordinate_type</a>;
<a name="l00047"></a>00047 };
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#72bb6868a8ad879fd7c85ad70a8ccabf">00050</a> <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">ProductSpace&lt; double, double &gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">DxD</a>;
<a name="l00051"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#efbf92002b7c651b64c0b7fa1ce2f971">00051</a> <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">ProductSpace&lt; double, std::complex&lt;double&gt;</a> &gt; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">DxCD</a>;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> space_type&gt;
<a name="l00055"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">00055</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">SampledData</a>
<a name="l00056"></a>00056 {
<a name="l00057"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">00057</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> space_type::abscissa_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a>;
<a name="l00058"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#df3f069aad9493bd1afe643e5189fb43">00058</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> space_type::ordinate_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#df3f069aad9493bd1afe643e5189fb43">ordinate_type</a>;
<a name="l00059"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#368898c59f33aec7712ff6b048af9889">00059</a>     <span class="keyword">typedef</span> std::pair&lt;abscissa_type,abscissa_type&gt; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#368898c59f33aec7712ff6b048af9889">domain_type</a>;
<a name="l00060"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#f56910f2cd309e7a0150760270c56723">00060</a>     <span class="keyword">typedef</span> std::vector&lt;ordinate_type&gt; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#f56910f2cd309e7a0150760270c56723">samples_type</a>;
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">00062</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#368898c59f33aec7712ff6b048af9889">domain_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">domain</a>; 
<a name="l00063"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">00063</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#f56910f2cd309e7a0150760270c56723">samples_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>;
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#2f1d6b08872644975d8b0470bbc1bbd3">00065</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#2f1d6b08872644975d8b0470bbc1bbd3">domainWidth</a>()<span class="keyword"> const</span>
<a name="l00066"></a>00066 <span class="keyword">    </span>{
<a name="l00067"></a>00067         <span class="keywordflow">return</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">domain</a>.second - <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">domain</a>.first;
<a name="l00068"></a>00068     }
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#a7ac1ed02b16b7080348ff66dfe1e852">00070</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#a7ac1ed02b16b7080348ff66dfe1e852">dx</a>()<span class="keyword"> const </span>
<a name="l00071"></a>00071 <span class="keyword">    </span>{   
<a name="l00072"></a>00072         <span class="keywordflow">return</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>.empty() ? 0 : <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#2f1d6b08872644975d8b0470bbc1bbd3">domainWidth</a>()/(<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>.size()-1);
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#fccb73275f78a8c02fae1dba5436d7fb">00075</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#fccb73275f78a8c02fae1dba5436d7fb">x</a>(<span class="keyword">typename</span> samples_type::size_type index)<span class="keyword"> const</span>
<a name="l00076"></a>00076 <span class="keyword">    </span>{
<a name="l00077"></a>00077         <span class="keywordflow">return</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">domain</a>.first + <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#2f1d6b08872644975d8b0470bbc1bbd3">domainWidth</a>() * index / (<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>.size()-1);
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#bd777c8ab4e5bc9591beb0e05e6e1573">00080</a>     <span class="keyword">typename</span> samples_type::size_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#bd777c8ab4e5bc9591beb0e05e6e1573">sampleIndex</a>(<span class="keyword">const</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a>&amp; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#fccb73275f78a8c02fae1dba5436d7fb">x</a>)<span class="keyword"> const</span>
<a name="l00081"></a>00081 <span class="keyword">    </span>{
<a name="l00082"></a>00082         <span class="keyword">typename</span> samples_type::size_type sampleCount = <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>.size();
<a name="l00083"></a>00083         <span class="keywordtype">int</span> result = (int)round((sampleCount-1)*(x-<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6420b8b1d3049904aa74683e7afee60b">domain</a>.first)/<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#2f1d6b08872644975d8b0470bbc1bbd3">domainWidth</a>());
<a name="l00084"></a>00084         <span class="keywordflow">if</span> (result &lt; 0) result = 0;
<a name="l00085"></a>00085         <span class="keywordflow">if</span> (result &gt; (<span class="keywordtype">int</span>)(sampleCount-1)) result = sampleCount-1;
<a name="l00086"></a>00086         <span class="keywordflow">return</span> (<span class="keyword">typename</span> samples_type::size_type)(result);
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6f03f0c5b719d1afa583791a3a283053">00089</a>     <span class="keyword">const</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#df3f069aad9493bd1afe643e5189fb43">ordinate_type</a>&amp; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#6f03f0c5b719d1afa583791a3a283053">sample</a>(<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#125129519e74af06c498d7aaa2da9143">abscissa_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#fccb73275f78a8c02fae1dba5436d7fb">x</a>)<span class="keyword"> const</span>
<a name="l00090"></a>00090 <span class="keyword">    </span>{
<a name="l00091"></a>00091         <span class="keywordflow">return</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#73c14f327990c6c13787c057614fed94">samples</a>[<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#bd777c8ab4e5bc9591beb0e05e6e1573">sampleIndex</a>(x)];
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> space_type&gt; 
<a name="l00097"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#7e8af691bea89e5cf8897357402534e7">00097</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SampledData&lt;space_type&gt;&amp; data)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099     os &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; data.domain.first &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; data.domain.second &lt;&lt; <span class="stringliteral">"] "</span> 
<a name="l00100"></a>00100        &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; data.samples.size() &lt;&lt; <span class="stringliteral">" samples)\n"</span>;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">SampledData&lt;space_type&gt;::samples_type::const_iterator</a> it=data.samples.begin();
<a name="l00103"></a>00103     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index=0; index!=data.samples.size(); ++index, ++it)
<a name="l00104"></a>00104         os &lt;&lt; data.x(index) &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; *it &lt;&lt; std::endl;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="keywordflow">return</span> os;
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00111"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">00111</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">KernelTraitsBase</a>
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <span class="comment">// When using a kernel function of type Kernel, </span>
<a name="l00114"></a>00114     <span class="comment">// KernelTraitsBase&lt;Kernel&gt; must define space_type, </span>
<a name="l00115"></a>00115     <span class="comment">// which in turn must define abscissa_type and ordinate_type, e.g:</span>
<a name="l00116"></a>00116     <span class="comment">//   typedef ProductSpace&lt;X,Y&gt; space_type;</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">// As a shortcut, the following default typedef allows a client to </span>
<a name="l00119"></a>00119     <span class="comment">// define space_type in the definition of Kernel:</span>
<a name="l00120"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html#4fe26ec2db7c04ab3cb4aed18530eb15">00120</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Kernel::space_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html#4fe26ec2db7c04ab3cb4aed18530eb15">space_type</a>;
<a name="l00121"></a>00121 };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">// partial specialization of KernelTraitsBase for function pointers</span>
<a name="l00125"></a>00125 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;
<a name="l00126"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base_3_01_y(_5)(_x)_4.html">00126</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">KernelTraitsBase</a>&lt;<a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940de5da2374173efa519482c866a5043a00">Y</a>(*)(X)&gt;
<a name="l00127"></a>00127 {
<a name="l00128"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base_3_01_y(_5)(_x)_4.html#3b368e43d143a3ad367be4b899c8a190">00128</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">ProductSpace&lt;X,Y&gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">space_type</a>;
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00133"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#c78fc957cda0c022b9446bec380d6da1">00133</a> <span class="keywordtype">void</span> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#c78fc957cda0c022b9446bec380d6da1">checkKernelConcept</a>()
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     <span class="keyword">struct </span>KernelConcept 
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137         <span class="keywordtype">void</span> check()
<a name="l00138"></a>00138         {
<a name="l00139"></a>00139             y = k(x);
<a name="l00140"></a>00140         }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">KernelTraitsBase&lt;Kernel&gt;::space_type::abscissa_type</a> x;
<a name="l00143"></a>00143         <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">KernelTraitsBase&lt;Kernel&gt;::space_type::ordinate_type</a> y;
<a name="l00144"></a>00144         Kernel k;
<a name="l00145"></a>00145     };
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <span class="comment">// force compile of KernelConcept::check()</span>
<a name="l00148"></a>00148     void (KernelConcept::*dummy)() = &amp;KernelConcept::check; 
<a name="l00149"></a>00149     (void)dummy;
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;
<a name="l00154"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html">00154</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html">Correlation</a>
<a name="l00155"></a>00155 {
<a name="l00156"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#a1ee0f68929d83e3db9e464dde2943e9">00156</a>     <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940de5da2374173efa519482c866a5043a00">Y</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#a1ee0f68929d83e3db9e464dde2943e9">dot</a>;
<a name="l00157"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#f7417686608a26d4a4705ddb5b19f0fe">00157</a>     <span class="keywordtype">double</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#f7417686608a26d4a4705ddb5b19f0fe">e2</a>;
<a name="l00158"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#476cfaedd42e5241398abeaec15b9154">00158</a>     <span class="keywordtype">double</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#476cfaedd42e5241398abeaec15b9154">tan2angle</a>;
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#a13203bd1abbc7b4fc3269d094366de6">00160</a>     <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#a13203bd1abbc7b4fc3269d094366de6">Correlation</a>(<a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940de5da2374173efa519482c866a5043a00">Y</a> _dot = 0, <span class="keywordtype">double</span> _e2 = 0, <span class="keywordtype">double</span> _tan2angle = 0)
<a name="l00161"></a>00161     :   <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#a1ee0f68929d83e3db9e464dde2943e9">dot</a>(_dot), <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#f7417686608a26d4a4705ddb5b19f0fe">e2</a>(_e2), <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#476cfaedd42e5241398abeaec15b9154">tan2angle</a>(_tan2angle)
<a name="l00162"></a>00162     {}
<a name="l00163"></a>00163 
<a name="l00164"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#51c1421d1215794ad81ebb542f2559cb">00164</a>     <span class="keywordtype">double</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#51c1421d1215794ad81ebb542f2559cb">angle</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> atan(sqrt(<a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html#476cfaedd42e5241398abeaec15b9154">tan2angle</a>))*180/M_PI;}
<a name="l00165"></a>00165 };
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;
<a name="l00169"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#ae446dabd1e89d2fe3bfa1f56ec5d86a">00169</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Correlation&lt;Y&gt;&amp; c)
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171     os &lt;&lt; <span class="stringliteral">"&lt;"</span> &lt;&lt; c.dot &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; c.e2 &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; c.angle() &lt;&lt; <span class="stringliteral">"&gt;"</span>;
<a name="l00172"></a>00172     <span class="keywordflow">return</span> os;
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00177"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">00177</a> <span class="keyword">struct </span><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits</a>
<a name="l00178"></a>00178 {
<a name="l00179"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#f86e74367289fb140d3f8cd68c12bd7f">00179</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits_base.html">KernelTraitsBase&lt;Kernel&gt;::space_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#f86e74367289fb140d3f8cd68c12bd7f">space_type</a>;
<a name="l00180"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#e58f393413c2484bd67bd8117d03a774">00180</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> space_type::abscissa_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#e58f393413c2484bd67bd8117d03a774">abscissa_type</a>;
<a name="l00181"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#c86254b95c9ae8d70113629cbf938a6b">00181</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> space_type::ordinate_type <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#c86254b95c9ae8d70113629cbf938a6b">ordinate_type</a>;
<a name="l00182"></a>00182 
<a name="l00183"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#af9c2e2b78384b94f6104fdb2ed00b35">00183</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">SampledData&lt;space_type&gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">sampled_data_type</a>;
<a name="l00184"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#431cbc76388dc1399924eff19bb19e53">00184</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html#f56910f2cd309e7a0150760270c56723">sampled_data_type::samples_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#431cbc76388dc1399924eff19bb19e53">samples_type</a>;
<a name="l00185"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#fc1ca5f63ddb678e5eae90631c597ed5">00185</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#431cbc76388dc1399924eff19bb19e53">samples_type</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#fc1ca5f63ddb678e5eae90631c597ed5">filter_type</a>;
<a name="l00186"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#2ab13791a893f75c2e479e373c4b087f">00186</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html">Correlation&lt;ordinate_type&gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_correlation.html">correlation_type</a>;
<a name="l00187"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#6f57d2644a6f9cca0be02b32dd98ab57">00187</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">ProductSpace&lt;abscissa_type, correlation_type&gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_product_space.html">correlation_space_type</a>;
<a name="l00188"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#d903c6093fab4b0c8534fb46eef769e9">00188</a>     <span class="keyword">typedef</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">SampledData&lt;correlation_space_type&gt;</a> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_sampled_data.html">correlation_data_type</a>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">// verify Kernel concept at compile time</span>
<a name="l00191"></a><a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#62952f208b3bbd53f38ecdc9c45b30bd">00191</a>     <span class="keyword">template</span> &lt;<span class="keywordtype">void</span>(*T)()&gt; <span class="keyword">struct </span>Dummy;
<a name="l00192"></a>00192     <span class="keyword">typedef</span> Dummy&lt; &amp;checkKernelConcept&lt;Kernel&gt; &gt; <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html#62952f208b3bbd53f38ecdc9c45b30bd">dummy</a>;
<a name="l00193"></a>00193 };
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html">00196</a> <span class="keyword">namespace </span>details {
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00200"></a>00200 <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::filter_type</a>
<a name="l00201"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#dd3f5f6f64209b9e6d5727e66467e0f8">00201</a> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#dd3f5f6f64209b9e6d5727e66467e0f8">createFilter</a>(<span class="keyword">const</span> Kernel&amp; kernel, 
<a name="l00202"></a>00202              <span class="keywordtype">int</span> sampleRadius,
<a name="l00203"></a>00203              <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::abscissa_type</a> dx,
<a name="l00204"></a>00204              <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::abscissa_type</a> shift)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     checkKernelConcept&lt;Kernel&gt;();
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::filter_type</a> filter;
<a name="l00209"></a>00209     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=-sampleRadius; i&lt;=sampleRadius; i++)
<a name="l00210"></a>00210         filter.push_back(kernel(i*dx - shift));
<a name="l00211"></a>00211     <span class="keywordflow">return</span> filter;
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="comment">// mimic complex&lt;&gt; functions</span>
<a name="l00216"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#313264101c8b982a32ec82d0d6f17529">00216</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#313264101c8b982a32ec82d0d6f17529">norm</a>(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> d*d;}
<a name="l00217"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#3b7550b90b2036dbe4d21425be648f35">00217</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#3b7550b90b2036dbe4d21425be648f35">conj</a>(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> d;}
<a name="l00218"></a>00218 
<a name="l00219"></a>00219  
<a name="l00220"></a>00220 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Filter&gt;
<a name="l00221"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#4c12b27d5ed479201948a74f726d19bf">00221</a> <span class="keywordtype">void</span> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#4c12b27d5ed479201948a74f726d19bf">normalizeFilter</a>(Filter&amp; filter)
<a name="l00222"></a>00222 {
<a name="l00223"></a>00223     <span class="keywordtype">double</span> normalization = 0;
<a name="l00224"></a>00224     <span class="keywordflow">for</span> (<span class="keyword">typename</span> Filter::const_iterator it=filter.begin(); it!=filter.end(); ++it)
<a name="l00225"></a>00225         normalization += <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#313264101c8b982a32ec82d0d6f17529">norm</a>(*it);
<a name="l00226"></a>00226     normalization = sqrt(normalization);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="keywordflow">for</span> (<span class="keyword">typename</span> Filter::iterator it=filter.begin(); it!=filter.end(); ++it)
<a name="l00229"></a>00229         *it /= normalization;
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00234"></a>00234 std::vector&lt;typename KernelTraits&lt;Kernel&gt;::filter_type&gt;
<a name="l00235"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#a7f7cfd3c7adaef22153d6dc1d6886e3">00235</a> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#a7f7cfd3c7adaef22153d6dc1d6886e3">createFilters</a>(<span class="keyword">const</span> Kernel&amp; kernel, 
<a name="l00236"></a>00236               <span class="keywordtype">int</span> sampleRadius,
<a name="l00237"></a>00237               <span class="keywordtype">int</span> subsampleFactor,
<a name="l00238"></a>00238               <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::abscissa_type</a> dx)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     checkKernelConcept&lt;Kernel&gt;();
<a name="l00241"></a>00241 
<a name="l00242"></a>00242     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::filter_type</a> filter_type;
<a name="l00243"></a>00243     std::vector&lt;filter_type&gt; filters;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;subsampleFactor; i++)
<a name="l00246"></a>00246         filters.push_back(<a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#dd3f5f6f64209b9e6d5727e66467e0f8">createFilter</a>(kernel, sampleRadius, dx, dx*i/subsampleFactor));
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     for_each(filters.begin(), filters.end(), normalizeFilter&lt;filter_type&gt;);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     <span class="keywordflow">return</span> filters;
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00255"></a>00255 <span class="keywordtype">void</span> 
<a name="l00256"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#34dae2fb6b7ea6905491c70a06e3c2f9">00256</a> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#34dae2fb6b7ea6905491c70a06e3c2f9">computeCorrelation</a>(<span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::samples_type::const_iterator</a> samples,
<a name="l00257"></a>00257                    <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::samples_type::const_iterator</a> samplesEnd,
<a name="l00258"></a>00258                    <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::samples_type::const_iterator</a> filter,
<a name="l00259"></a>00259                    <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::correlation_type</a>&amp; result)
<a name="l00260"></a>00260 {
<a name="l00261"></a>00261     checkKernelConcept&lt;Kernel&gt;();
<a name="l00262"></a>00262     result.dot = 0; 
<a name="l00263"></a>00263     <span class="keywordtype">double</span> normData = 0;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="keywordflow">for</span> (; samples!=samplesEnd; ++samples, ++filter)
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         result.dot += (*samples) * <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#3b7550b90b2036dbe4d21425be648f35">conj</a>(*filter); 
<a name="l00268"></a>00268         normData += <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#313264101c8b982a32ec82d0d6f17529">norm</a>(*samples);
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     <span class="keywordtype">double</span> normDot = <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#313264101c8b982a32ec82d0d6f17529">norm</a>(result.dot);
<a name="l00272"></a>00272     result.e2 = std::max(normData - normDot, 0.);
<a name="l00273"></a>00273     result.tan2angle = normDot&gt;0 ? result.e2/normDot : std::numeric_limits&lt;double&gt;::infinity();
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 } <span class="comment">// namespace details</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Kernel&gt;
<a name="l00281"></a>00281 <span class="keyword">typename</span> KernelTraits&lt;Kernel&gt;::correlation_data_type
<a name="l00282"></a><a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#7534100a699f374ce86d14c87ec8677e">00282</a> <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter.html#7534100a699f374ce86d14c87ec8677e">computeCorrelationData</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::sampled_data_type</a>&amp; data, 
<a name="l00283"></a>00283                        <span class="keyword">const</span> Kernel&amp; kernel, 
<a name="l00284"></a>00284                        <span class="keywordtype">int</span> sampleRadius,
<a name="l00285"></a>00285                        <span class="keywordtype">int</span> subsampleFactor)
<a name="l00286"></a>00286 {
<a name="l00287"></a>00287     checkKernelConcept&lt;Kernel&gt;();
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::correlation_data_type</a> result_type;
<a name="l00290"></a>00290     result_type result;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     result.domain = data.domain;
<a name="l00293"></a>00293     <span class="keywordflow">if</span> (data.samples.empty()) <span class="keywordflow">return</span> result;
<a name="l00294"></a>00294     result.samples.resize((data.samples.size()-1) * subsampleFactor + 1); 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::filter_type</a> filter_type; 
<a name="l00297"></a>00297     std::vector&lt;filter_type&gt; filters = <a class="code" href="namespacepwiz_1_1math_1_1_matched_filter_1_1details.html#a7f7cfd3c7adaef22153d6dc1d6886e3">details::createFilters</a>(kernel, 
<a name="l00298"></a>00298                                                               sampleRadius, 
<a name="l00299"></a>00299                                                               subsampleFactor, 
<a name="l00300"></a>00300                                                               data.dx());
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structpwiz_1_1math_1_1_matched_filter_1_1_kernel_traits.html">KernelTraits&lt;Kernel&gt;::samples_type</a> samples_type;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sampleIndex = sampleRadius;
<a name="l00305"></a>00305     <span class="keywordflow">for</span> (<span class="keyword">typename</span> samples_type::const_iterator itData = data.samples.begin() + sampleRadius; 
<a name="l00306"></a>00306          itData + sampleRadius != data.samples.end(); ++itData, ++sampleIndex)
<a name="l00307"></a>00307     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> filterIndex=0; filterIndex&lt;filters.size(); ++filterIndex)
<a name="l00308"></a>00308     {
<a name="l00309"></a>00309         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = sampleIndex * filters.size() + filterIndex;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <span class="keywordflow">if</span> (index &gt;= result.samples.size()) <span class="comment">// only when sampleRadius==0, filterIndex&gt;0</span>
<a name="l00312"></a>00312             <span class="keywordflow">break</span>;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         details::computeCorrelation&lt;Kernel&gt;(itData-sampleRadius, itData+sampleRadius+1,
<a name="l00315"></a>00315                                             filters[filterIndex].begin(),
<a name="l00316"></a>00316                                             result.samples[index]);
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <span class="keywordflow">return</span> result; 
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 } <span class="comment">// namespace MatchedFilter</span>
<a name="l00324"></a>00324 } <span class="comment">// namespace math </span>
<a name="l00325"></a>00325 } <span class="comment">// namespace pwiz</span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="preprocessor">#endif // _MATCHEDFILTER_HPP_</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Apr 18 11:39:52 2008 for ProteoWizard by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
