<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ProteoWizard: pwiz::math Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespacepwiz.html">pwiz</a>::<a class="el" href="namespacepwiz_1_1math.html">math</a></div>
<h1>pwiz::math Namespace Reference</h1>
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_linear_least_squares_3_01_linear_least_squares_type___l_u_01_4.html">LinearLeastSquares&lt; LinearLeastSquaresType_LU &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_linear_least_squares_3_01_linear_least_squares_type___q_r_01_4.html">LinearLeastSquares&lt; LinearLeastSquaresType_QR &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_linear_solver_3_01_linear_solver_type___l_u_01_4.html">LinearSolver&lt; LinearSolverType_LU &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_linear_solver_3_01_linear_solver_type___q_r_01_4.html">LinearSolver&lt; LinearSolverType_QR &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_parabola.html">Parabola</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_random.html">Random</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpwiz_1_1math_1_1_stats.html">Stats</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math_1_1_matched_filter.html">MatchedFilter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math_1_1types.html">types</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6e">LinearLeastSquaresType</a> { <a class="el" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6ea95d2250dcd89612081bd022b2ab66d2">LinearLeastSquaresType_LU</a>, 
<a class="el" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6e777af03628cbf31c792f1979764cdf52">LinearLeastSquaresType_QR</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4c">LinearSolverType</a> { <a class="el" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4c3c2b6620d157635e5296e5f4b557ef59">LinearSolverType_LU</a>, 
<a class="el" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4ca64515c6e9f9fcd73f8f25773f8bddd4">LinearSolverType_QR</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::complex&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#d7eadd8e690a782251402eb49babff3d">erf</a> (const std::complex&lt; double &gt; &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error function for complex argument.  <a href="#d7eadd8e690a782251402eb49babff3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::complex&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#afa9b9a3cb1d87f0a06adf5241b76fc8">erf_series2</a> (const std::complex&lt; double &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#da5912bbb8e406fa8a115710a55733e5">TransposeMultiply</a> (const ublas::vector&lt; T &gt; &amp;vector, ublas::matrix&lt; T &gt; &amp;result, size_t size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#bd2d504ee60052109a9b6f888e536390">HouseholderCornerSubstraction</a> (ublas::matrix&lt; T &gt; &amp;LeftLarge, const ublas::matrix&lt; T &gt; &amp;RightSmall)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#6f6174c502babde0762006c418aeaed1">HouseholderQR</a> (const ublas::matrix&lt; T &gt; &amp;M, ublas::matrix&lt; T &gt; &amp;Q, ublas::matrix&lt; T &gt; &amp;R)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#d55a5c430461f10d43b3bddc14d95293">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpwiz_1_1math_1_1_parabola.html">Parabola</a> &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class matrix_type, class vector_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#cfbfd7e0572df9b58d7d2c31b65c8a94">Reflector</a> (const vector_type &amp;x, matrix_type &amp;F)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class matrix_type, class vector_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">matrix_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#8c819339be2b0052339742e19beb7c91">Reflector</a> (const vector_type &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class matrix_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepwiz_1_1math.html#cc6a9afb15869849a966f9f2c2a46f69">qr</a> (const matrix_type &amp;A, matrix_type &amp;Q, matrix_type &amp;R)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="73e80e15c15eb1e96c7ade144bf94b6e"></a><!-- doxytag: member="pwiz::math::LinearLeastSquaresType" ref="73e80e15c15eb1e96c7ade144bf94b6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6e">pwiz::math::LinearLeastSquaresType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="73e80e15c15eb1e96c7ade144bf94b6ea95d2250dcd89612081bd022b2ab66d2"></a><!-- doxytag: member="LinearLeastSquaresType_LU" ref="73e80e15c15eb1e96c7ade144bf94b6ea95d2250dcd89612081bd022b2ab66d2" args="" -->LinearLeastSquaresType_LU</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="73e80e15c15eb1e96c7ade144bf94b6e777af03628cbf31c792f1979764cdf52"></a><!-- doxytag: member="LinearLeastSquaresType_QR" ref="73e80e15c15eb1e96c7ade144bf94b6e777af03628cbf31c792f1979764cdf52" args="" -->LinearLeastSquaresType_QR</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="_linear_least_squares_8hpp-source.html#l00034">34</a> of file <a class="el" href="_linear_least_squares_8hpp-source.html">LinearLeastSquares.hpp</a>.<div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {<a class="code" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6ea95d2250dcd89612081bd022b2ab66d2">LinearLeastSquaresType_LU</a>, <a class="code" href="namespacepwiz_1_1math.html#73e80e15c15eb1e96c7ade144bf94b6e777af03628cbf31c792f1979764cdf52">LinearLeastSquaresType_QR</a>};
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="839cccedf818028fbac84bc0f352fa4c"></a><!-- doxytag: member="pwiz::math::LinearSolverType" ref="839cccedf818028fbac84bc0f352fa4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4c">pwiz::math::LinearSolverType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="839cccedf818028fbac84bc0f352fa4c3c2b6620d157635e5296e5f4b557ef59"></a><!-- doxytag: member="LinearSolverType_LU" ref="839cccedf818028fbac84bc0f352fa4c3c2b6620d157635e5296e5f4b557ef59" args="" -->LinearSolverType_LU</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="839cccedf818028fbac84bc0f352fa4ca64515c6e9f9fcd73f8f25773f8bddd4"></a><!-- doxytag: member="LinearSolverType_QR" ref="839cccedf818028fbac84bc0f352fa4ca64515c6e9f9fcd73f8f25773f8bddd4" args="" -->LinearSolverType_QR</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="_linear_solver_8hpp-source.html#l00046">46</a> of file <a class="el" href="_linear_solver_8hpp-source.html">LinearSolver.hpp</a>.<div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {<a class="code" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4c3c2b6620d157635e5296e5f4b557ef59">LinearSolverType_LU</a>, <a class="code" href="namespacepwiz_1_1math.html#839cccedf818028fbac84bc0f352fa4ca64515c6e9f9fcd73f8f25773f8bddd4">LinearSolverType_QR</a>};
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d7eadd8e690a782251402eb49babff3d"></a><!-- doxytag: member="pwiz::math::erf" ref="d7eadd8e690a782251402eb49babff3d" args="(const std::complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; pwiz::math::erf           </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Error function for complex argument. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Adam Piatyszek</dd></dl>
This function calculates a well known error function <code>erf(z)</code> for complex <code>z</code>. The implementation is based on unofficial implementation for Octave. Here is a part of the author's note from original sources:<p>
Put together by John Smith john at arrows dot demon dot co dot uk, using ideas by others.<p>
Calculate <code>erf(z)</code> for complex <code>z</code>. Three methods are implemented; which one is used depends on z.<p>
The code includes some hard coded constants that are intended to give about 14 decimal places of accuracy. This is appropriate for 64-bit floating point numbers. 
<p>
Referenced by <a class="el" href="erf_test_8cpp-source.html#l00099">test_it()</a>, and <a class="el" href="erf_test_8cpp-source.html#l00114">test_itvs2()</a>.
</div>
</div><p>
<a class="anchor" name="afa9b9a3cb1d87f0a06adf5241b76fc8"></a><!-- doxytag: member="pwiz::math::erf_series2" ref="afa9b9a3cb1d87f0a06adf5241b76fc8" args="(const std::complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; pwiz::math::erf_series2           </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Referenced by <a class="el" href="erf_test_8cpp-source.html#l00114">test_itvs2()</a>.
</div>
</div><p>
<a class="anchor" name="da5912bbb8e406fa8a115710a55733e5"></a><!-- doxytag: member="pwiz::math::TransposeMultiply" ref="da5912bbb8e406fa8a115710a55733e5" args="(const ublas::vector&lt; T &gt; &amp;vector, ublas::matrix&lt; T &gt; &amp;result, size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pwiz::math::TransposeMultiply           </td>
          <td>(</td>
          <td class="paramtype">const ublas::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="_householder_q_r_8hpp-source.html#l00037">37</a> of file <a class="el" href="_householder_q_r_8hpp-source.html">HouseholderQR.hpp</a>.
<p>
Referenced by <a class="el" href="_householder_q_r_8hpp-source.html#l00077">HouseholderQR()</a>.<div class="fragment"><pre class="fragment"><a name="l00040"></a>00040 {
<a name="l00041"></a>00041   result.resize (size,size);
<a name="l00042"></a>00042   result.clear ();
<a name="l00043"></a>00043   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row=0; row&lt; vector.size(); ++row)
<a name="l00044"></a>00044     {
<a name="l00045"></a>00045       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col=0; col &lt; vector.size(); ++col)
<a name="l00046"></a>00046         result(row,col) = vector(col) * vector(row);
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bd2d504ee60052109a9b6f888e536390"></a><!-- doxytag: member="pwiz::math::HouseholderCornerSubstraction" ref="bd2d504ee60052109a9b6f888e536390" args="(ublas::matrix&lt; T &gt; &amp;LeftLarge, const ublas::matrix&lt; T &gt; &amp;RightSmall)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pwiz::math::HouseholderCornerSubstraction           </td>
          <td>(</td>
          <td class="paramtype">ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>LeftLarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>RightSmall</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="_householder_q_r_8hpp-source.html#l00052">52</a> of file <a class="el" href="_householder_q_r_8hpp-source.html">HouseholderQR.hpp</a>.
<p>
Referenced by <a class="el" href="_householder_q_r_8hpp-source.html#l00077">HouseholderQR()</a>.<div class="fragment"><pre class="fragment"><a name="l00054"></a>00054 {
<a name="l00055"></a>00055   <span class="keyword">using namespace </span>boost::numeric::ublas;
<a name="l00056"></a>00056   <span class="keyword">using namespace </span>std; 
<a name="l00057"></a>00057   <span class="keywordflow">if</span>( 
<a name="l00058"></a>00058      !( 
<a name="l00059"></a>00059        (LeftLarge.size1() &gt;= RightSmall.size1())
<a name="l00060"></a>00060        &amp;&amp; (LeftLarge.size2() &gt;= RightSmall.size2())
<a name="l00061"></a>00061         ) 
<a name="l00062"></a>00062       )
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064       cerr &lt;&lt; <span class="stringliteral">"invalid matrix dimensions"</span> &lt;&lt; endl;
<a name="l00065"></a>00065       <span class="keywordflow">return</span>;
<a name="l00066"></a>00066     }  
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   size_t row_offset = LeftLarge.size2() - RightSmall.size2();
<a name="l00069"></a>00069   size_t col_offset = LeftLarge.size1() - RightSmall.size1();
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row = 0; row &lt; RightSmall.size2(); ++row )
<a name="l00072"></a>00072     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col = 0; col &lt; RightSmall.size1(); ++col )
<a name="l00073"></a>00073       LeftLarge(col_offset+col,row_offset+row) -= RightSmall(col,row);
<a name="l00074"></a>00074 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6f6174c502babde0762006c418aeaed1"></a><!-- doxytag: member="pwiz::math::HouseholderQR" ref="6f6174c502babde0762006c418aeaed1" args="(const ublas::matrix&lt; T &gt; &amp;M, ublas::matrix&lt; T &gt; &amp;Q, ublas::matrix&lt; T &gt; &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pwiz::math::HouseholderQR           </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::matrix&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="_householder_q_r_8hpp-source.html#l00077">77</a> of file <a class="el" href="_householder_q_r_8hpp-source.html">HouseholderQR.hpp</a>.
<p>
References <a class="el" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d9426fa62dba2bbc9f7c03bd6d46ed8d9">pwiz::proteome::Chemistry::Element::H</a>, <a class="el" href="_householder_q_r_8hpp-source.html#l00052">HouseholderCornerSubstraction()</a>, and <a class="el" href="_householder_q_r_8hpp-source.html#l00037">TransposeMultiply()</a>.
<p>
Referenced by <a class="el" href="_householder_q_r_test_8cpp-source.html#l00018">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00080"></a>00080 {
<a name="l00081"></a>00081   <span class="keyword">using namespace </span>boost::numeric::ublas;
<a name="l00082"></a>00082   <span class="keyword">using namespace </span>std;  
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="keywordflow">if</span>( 
<a name="l00085"></a>00085      !( 
<a name="l00086"></a>00086        (M.size1() == M.size2())
<a name="l00087"></a>00087         ) 
<a name="l00088"></a>00088       )
<a name="l00089"></a>00089     {
<a name="l00090"></a>00090       cerr &lt;&lt; <span class="stringliteral">"invalid matrix dimensions"</span> &lt;&lt; endl;
<a name="l00091"></a>00091       <span class="keywordflow">return</span>;
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093   size_t size = M.size1();
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="comment">// init Matrices</span>
<a name="l00096"></a>00096   matrix&lt;T&gt; <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d9426fa62dba2bbc9f7c03bd6d46ed8d9">H</a>, HTemp;
<a name="l00097"></a>00097   HTemp = identity_matrix&lt;T&gt;(size);
<a name="l00098"></a>00098   Q = identity_matrix&lt;T&gt;(size);
<a name="l00099"></a>00099   R = M;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="comment">// find Householder reflection matrices</span>
<a name="l00102"></a>00102   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col = 0; col &lt; size-1; ++col)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104       <span class="comment">// create X vector</span>
<a name="l00105"></a>00105       ublas::vector&lt;T&gt; RRowView = column(R,col);      
<a name="l00106"></a>00106       vector_range&lt; ublas::vector&lt;T&gt; &gt; X2 (RRowView, range (col, size));
<a name="l00107"></a>00107       ublas::vector&lt;T&gt; X = X2;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109       <span class="comment">// X -&gt; U~</span>
<a name="l00110"></a>00110       <span class="keywordflow">if</span>(X(0) &gt;= 0)
<a name="l00111"></a>00111         X(0) += norm_2(X);
<a name="l00112"></a>00112       <span class="keywordflow">else</span>
<a name="l00113"></a>00113         X(0) += -1*norm_2(X);      
<a name="l00114"></a>00114 
<a name="l00115"></a>00115       HTemp.resize(X.size(),X.size(),<span class="keyword">true</span>);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117       <a class="code" href="namespacepwiz_1_1math.html#da5912bbb8e406fa8a115710a55733e5">TransposeMultiply</a>(X, HTemp, X.size());
<a name="l00118"></a>00118 
<a name="l00119"></a>00119       <span class="comment">// HTemp = the 2UUt part of H </span>
<a name="l00120"></a>00120       HTemp *= ( 2 / inner_prod(X,X) );
<a name="l00121"></a>00121 
<a name="l00122"></a>00122       <span class="comment">// H = I - 2UUt</span>
<a name="l00123"></a>00123       H = identity_matrix&lt;T&gt;(size);
<a name="l00124"></a>00124       <a class="code" href="namespacepwiz_1_1math.html#bd2d504ee60052109a9b6f888e536390">HouseholderCornerSubstraction</a>(H,HTemp);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126       <span class="comment">// add H to Q and R</span>
<a name="l00127"></a>00127       Q = prod(Q,H);
<a name="l00128"></a>00128       R = prod(H,R);
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d55a5c430461f10d43b3bddc14d95293"></a><!-- doxytag: member="pwiz::math::operator&lt;&lt;" ref="d55a5c430461f10d43b3bddc14d95293" args="(std::ostream &amp;os, const Parabola &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pwiz::math::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Parabola &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cfbfd7e0572df9b58d7d2c31b65c8a94"></a><!-- doxytag: member="pwiz::math::Reflector" ref="cfbfd7e0572df9b58d7d2c31b65c8a94" args="(const vector_type &amp;x, matrix_type &amp;F)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type, class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pwiz::math::Reflector           </td>
          <td>(</td>
          <td class="paramtype">const vector_type &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="qr_8hpp-source.html#l00039">39</a> of file <a class="el" href="qr_8hpp-source.html">qr.hpp</a>.
<p>
Referenced by <a class="el" href="qr_8hpp-source.html#l00081">qr()</a>.<div class="fragment"><pre class="fragment"><a name="l00040"></a>00040 {
<a name="l00041"></a>00041     <span class="keyword">namespace </span>ublas = boost::numeric::ublas;
<a name="l00042"></a>00042     <span class="keyword">using namespace </span>ublas;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix_type::value_type value_type;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     unit_vector&lt;value_type&gt; e1(x.size(), 0);
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="comment">//v_k = -sgn( x(1) ) * inner_prod(x) * e1 + x;</span>
<a name="l00049"></a>00049     <span class="keywordtype">double</span> x_2 = norm_2(x);
<a name="l00050"></a>00050     ublas::vector&lt;value_type&gt; v_k((x(0) &gt;= 0 ? x_2 : -1 * x_2) * e1 + x);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="comment">//v_k = v_k / norm_2(v_k);</span>
<a name="l00053"></a>00053     <span class="keywordtype">double</span> norm_vk = norm_2(v_k);
<a name="l00054"></a>00054     <span class="keywordflow">if</span> (norm_vk != 0)
<a name="l00055"></a>00055         v_k /= norm_2(v_k);
<a name="l00056"></a>00056     
<a name="l00057"></a>00057     <span class="comment">// F = A(k:m,k:n) - 2 * outer_prod(v_k, v_k) * A(k:m,k:n)</span>
<a name="l00058"></a>00058     identity_matrix&lt;value_type&gt; eye(v_k.size());
<a name="l00059"></a>00059     <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a> = matrix_type(v_k.size(), v_k.size());
<a name="l00060"></a>00060     
<a name="l00061"></a>00061     F = eye - 2. * outer_prod(v_k, v_k);
<a name="l00062"></a>00062 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8c819339be2b0052339742e19beb7c91"></a><!-- doxytag: member="pwiz::math::Reflector" ref="8c819339be2b0052339742e19beb7c91" args="(const vector_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type, class vector_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">matrix_type pwiz::math::Reflector           </td>
          <td>(</td>
          <td class="paramtype">const vector_type &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="qr_8hpp-source.html#l00069">69</a> of file <a class="el" href="qr_8hpp-source.html">qr.hpp</a>.
<p>
References <a class="el" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">pwiz::proteome::Chemistry::Element::F</a>.
<p>
Referenced by <a class="el" href="qr_test_8cpp-source.html#l00056">testReflector()</a>.<div class="fragment"><pre class="fragment"><a name="l00070"></a>00070 {
<a name="l00071"></a>00071     <span class="keyword">using namespace </span>boost::numeric::ublas;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     matrix_type <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>(x.size(), x.size());
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     Reflector&lt;matrix_type, vector_type&gt;(x, <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     <span class="keywordflow">return</span> <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>;
<a name="l00078"></a>00078 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cc6a9afb15869849a966f9f2c2a46f69"></a><!-- doxytag: member="pwiz::math::qr" ref="cc6a9afb15869849a966f9f2c2a46f69" args="(const matrix_type &amp;A, matrix_type &amp;Q, matrix_type &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pwiz::math::qr           </td>
          <td>(</td>
          <td class="paramtype">const matrix_type &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="qr_8hpp-source.html#l00081">81</a> of file <a class="el" href="qr_8hpp-source.html">qr.hpp</a>.
<p>
References <a class="el" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">pwiz::proteome::Chemistry::Element::F</a>, and <a class="el" href="qr_8hpp-source.html#l00039">Reflector()</a>.
<p>
Referenced by <a class="el" href="_linear_solver_8hpp-source.html#l00088">pwiz::math::LinearSolver&lt; LinearSolverType_QR &gt;::solve()</a>.<div class="fragment"><pre class="fragment"><a name="l00082"></a>00082 {
<a name="l00083"></a>00083     <span class="keyword">using namespace </span>boost::numeric::ublas;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix_type::size_type size_type;
<a name="l00086"></a>00086     <span class="keyword">typedef</span> <span class="keyword">typename</span> matrix_type::value_type value_type;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="comment">// TODO resize Q and R to match the needed size.</span>
<a name="l00089"></a>00089     <span class="keywordtype">int</span> m=A.size1();
<a name="l00090"></a>00090     <span class="keywordtype">int</span> n=A.size2();
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     identity_matrix&lt;value_type&gt; ident(m);
<a name="l00093"></a>00093     <span class="keywordflow">if</span> (Q.size1() != ident.size1() || Q.size2() != ident.size2())
<a name="l00094"></a>00094         Q = matrix_type(m, m);
<a name="l00095"></a>00095     Q.assign(ident);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     R.clear();
<a name="l00098"></a>00098     R = A;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="keywordflow">for</span> (size_type k=0; k&lt; R.size1() &amp;&amp; k&lt;R.size2(); k++)
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102         slice s1(k, 1, m - k);
<a name="l00103"></a>00103         slice s2(k, 0, m - k);
<a name="l00104"></a>00104         unit_vector&lt;value_type&gt; e1(m - k, 0);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         <span class="comment">// x = A(k:m, k);</span>
<a name="l00107"></a>00107         matrix_vector_slice&lt;matrix_type&gt; x(R, s1, s2);
<a name="l00108"></a>00108         matrix_type <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>(x.size(), x.size());
<a name="l00109"></a>00109         
<a name="l00110"></a>00110         <a class="code" href="namespacepwiz_1_1math.html#8c819339be2b0052339742e19beb7c91">Reflector</a>(x, <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         matrix_type temp = subrange(R, k, m, k, n);
<a name="l00113"></a>00113         <span class="comment">//F = prod(F, temp);</span>
<a name="l00114"></a>00114         subrange(R, k, m, k, n) = prod(<a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>, temp);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <span class="comment">// &lt;&lt;----------------------------------------------&gt;&gt;</span>
<a name="l00117"></a>00117         <span class="comment">// forming Q</span>
<a name="l00118"></a>00118         identity_matrix&lt;value_type&gt; iqk(A.size1());
<a name="l00119"></a>00119         matrix_type Q_k(iqk);
<a name="l00120"></a>00120         
<a name="l00121"></a>00121         subrange(Q_k, Q_k.size1() - <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>.size1(), Q_k.size1(),
<a name="l00122"></a>00122                  Q_k.size2() - <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>.size2(), Q_k.size2()) = <a class="code" href="namespacepwiz_1_1proteome_1_1_chemistry_1_1_element.html#a0437c6647d8ed934a906579d7ef940d8b59f052304a1ce4acb02828dd6d5efe">F</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         Q = prod(Q, Q_k);
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 14 17:16:09 2008 for ProteoWizard by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
