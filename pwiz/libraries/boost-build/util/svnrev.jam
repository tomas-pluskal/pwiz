import project ;
import path ;
import feature ;
import toolset ;
import targets ;
import type ;
import generators ;
import sequence ;
import "class" : new ;


rule get-revision-info ( filepath + : warn-on-missing ? : print-revision-info ? )
{
}
NATIVE_RULE svnrev : get-revision-info ;



type.register SVNREV : : HPP ;

rule svnrev.generate-version-header-action
{
}

actions svnrev.generate-version-header-action
{
@($(STDOUT):E=// This file was generated by the "svnrev" utility
// You should not modify it manually, as it may be re-generated.
//
// $Revision: $(REVISION) $
// $Date: $(DATE) $
//

#ifndef SVNREV_HPP
#define SVNREV_HPP


#define SVN_REV       $(REVISION)
#define SVN_REVDATE   "$(DATE)"


#endif /* SVNREV_HPP */
) > "$(<)"
}

class svnrev-generator : generator
{
    import path property-set sequence svnrev ;

    rule generated-targets ( sources + : property-set : project name ? )
    {
        local pwd = [ path.make [ path.pwd ] ] ;
        local real-sources ;
        for local source in $(sources)
        {
            local source-path = [ path.make [ $(source).name ] ] ;

            if ! [ path.is-rooted $(source-path) ]
            {
                source-path = [ path.join [ path.make [ $(source).path ] ] $(source-path) ] ;
                if ! [ path.is-rooted $(source-path) ]
                {
                    source-path = [ path.root $(source-path) $(pwd) ] ;
                }
            }

            source-path = [ path.native $(source-path) ] ;
            if ! $(source-path) in $(real-sources) { real-sources += $(source-path) ; }
        }
        #for local m in [ SORT $(real-sources) ] { echo "Real source: " $(m) ; }

        local properties = [ $(property-set).raw ] ;

        local existing-header = $(name).hpp ;
        if <location> in $(properties:G) && ! [ path.is-rooted $(existing-header) ]
        {
            local location = [ feature.get-values location : $(properties) ] ;
            existing-header = $(location)/$(existing-header) ;
        }

        local existing-revision-info ;
        if [ path.exists $(existing-header) ]
        {
            existing-revision-info = [ svnrev.get-revision-info $(existing-header) ] ;
            #echo Existing header revision info: $(existing-revision-info) ;
        }

        local revision-info = [ svnrev.get-revision-info $(real-sources) ] ;
        #echo New revision info: $(revision-info) ;

        local t = [ generator.generated-targets $(sources) : $(property-set) : $(project) $(name) ] ;
        local actual-result = [ $(t).actualize ] ;

        REVISION on $(actual-result) = $(revision-info[1]) ;

        local year = $(revision-info[2]) ;
        local month = $(revision-info[3]) ;
        local day = $(revision-info[4]) ;
        DATE on $(actual-result) = $(year)-$(month)-$(day) ;

        if ! $(existing-revision-info) ||
           $(existing-revision-info[1]) != $(revision-info[1])
        {
            ALWAYS $(actual-result) ;
            return $(t) ;
        }
        else
        {
            NOCARE $(actual-result) ;
            return ;
        }
    }
}

generators.register [ new svnrev-generator svnrev.svnrev.generate-version-header-action true : : SVNREV ] ;

.filename = svnrev.hpp ;

rule recursion-filter ( source )
{
    if $(source:D=) != $(.filename) { return true ; }
}

rule generate-version-header ( filename ? : sources-with-rcs-keywords * : requirements * )
{
    filename ?= svnrev.hpp ;
    .filename = $(filename) ;
    sources-with-rcs-keywords = [ sequence.filter recursion-filter : $(sources-with-rcs-keywords) ] ;

    # default output path is the current directory
    if ! <location> in $(requirements:G) { requirements += <location>. ; }

    targets.create-typed-target SVNREV : [ project.current ] :
        $(filename) : $(sources-with-rcs-keywords) : $(requirements) ;
}