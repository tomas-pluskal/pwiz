import property ;
import project ;
import feature ;
import set ;
import stage ;
import common ;
import path ;
import type ;
import targets ;
import toolset ;
import generators ;
import scanner ;
import "class" : new ;

# Make this module into a project.
project.initialize $(__name__) ;
project bcp ;

rule init ( boost-root : requirements * )
{
    if ! $(.initialized)
    {
        .initialized = true ;

        .boost-root = [ path.make $(boost-root) ] ;

        path-constant BOOST_PATH : [ boost-root ] ;
        using ext-boost : 1.39.0 : $(BOOST_PATH) ;

        exe bcp
        : # sources
            [ path.glob $(BOOST_PATH)/../boost_aux/tools/bcp : *.cpp ] # TODO: patch changes to official bcp
            /ext/boost//filesystem
            /ext/boost//regex
            /ext/boost//prg_exec_monitor
        : # requirements
            $(requirements)
        ;
    }
}

rule boost-root { return $(.boost-root) ; }



# The action has to invoke the tool built in other
# parts of the project. The <bcp> feature is used
# to specify the location of the tool, and the flags
# statement below make the full path to the tool
# available inside the action.
feature.feature bcp : : dependency free ;
toolset.flags bcp.bcp COMMAND <bcp> ;

type.register BCP : bcp ;

import os ;
if [ os.name ] = NT
{
    .NUL = nul ;
}
else
{
    .NUL = /dev/null ;
}

actions quietly bcp.create bind COMMAND
{
    @($(STDOUT):E=$(MODULE_LIST)) > "$(MODULE_LIST_FILENAME)"
    $(COMMAND) --scan --boost=$(BOOST_PATH) --module-list-file=$(MODULE_LIST_FILENAME) $(<:D) > $(.NUL)
}

class bcp-generator : generator
{
    import path property-set ;

    rule recurse-to-sources ( roots * )
    {
        local real-sources ;
        for local r in $(roots)
        {
            #echo "r: " [ $(r).str ] ;
            local temp = [ virtual-target.traverse $(r) : include-root : include-sources ] ;
            if $(temp[2])
            {
                for local t in $(temp[2-])
                {
                    #echo "t: " [ $(t).str ] ;
                    if ! $(t) = $(r) &&
                       [ type.is-derived [ $(t).type ] EXE ] ||
                       [ type.is-derived [ $(t).type ] LIB ] ||
                       [ type.is-derived [ $(t).type ] OBJ ] ||
                       [ type.is-derived [ $(t).type ] UNIT_TEST ] ||
                       [ type.is-derived [ $(t).type ] TEST ]
                    {
                        real-sources += [ recurse-to-sources $(t) ] ;
                    }
                    else if [ type.is-derived [ $(t).type ] CPP ] ||
                            [ type.is-derived [ $(t).type ] HPP ] ||
                            [ type.is-derived [ $(t).type ] C ] ||
                            [ type.is-derived [ $(t).type ] H ]
                    {
                        real-sources += $(t) ;
                    }
                    else
                    {
                        echo "Warning: ignoring dependency with unknown type:" [ $(t).str ] ;
                    }
                }
            }
            else
            {
                real-sources += $(r) ;
            }
        }
        return $(real-sources) ;
    }

    rule generated-targets ( sources + : property-set : project name ? )
    {
        #for local r in $(sources) { echo "Input source: " [ $(r).actualize [ type.get-scanner [ $(r).type ] : $(property-set) ] ] [ $(r).dependencies ] ; }
        local real-sources = [ recurse-to-sources $(sources) ] ;
        #for local r in $(sorted-sources) { echo "Real source: " $(r) ; }

        local pwd = [ path.make [ path.pwd ] ] ;
        local modules ;
        for local source in $(real-sources)
        {
            local source-path = [ $(source).name ] ;

            if ! [ path.is-rooted $(source-path) ]
            {
                source-path = [ path.root [ path.join [ $(source).path ] $(source-path:D=) ] $(pwd) ] ;
            }

            if ! $(source-path) in $(modules) { modules += [ path.native $(source-path) ] ; }
        }
        #for local m in [ SORT $(modules) ] { echo "Module: " $(m) ; }

        local properties = [ $(property-set).raw ] ;
        local location = [ feature.get-values location : $(properties) ] ;
        local host-os = [ feature.get-values host-os : $(properties) ] ;
        local module_list_filename = [ path.native $(location:S=)_module_list.txt ] ;

        local NL = "
" ;
        local bcp = [ property.select <bcp> : [ $(property-set).raw ] ] ;
        local t = [ generator.generated-targets $(real-sources) $(bcp:G=)
                            : $(property-set) : $(project) $(name) ] ;
        local actual-result = [ $(t).actualize ] ;
        ALWAYS $(actual-result) ;
        MODULE_LIST_FILENAME on $(actual-result) = $(module_list_filename) ;
        MODULE_LIST on $(actual-result) = $(modules:J=$(NL)) ;
        return $(t) ;
    }
}

generators.register [ new bcp-generator bcp.bcp.create true : : BCP ] ;

rule copy-boost-dependencies ( target-name : sources + : requirements * )
{
    targets.create-typed-target BCP : [ project.current ] :
        $(target-name) : $(sources) : $(requirements) <bcp>/bcp//bcp ;
}
