import property ;
import project ;
import feature ;
import set ;
import stage ;
import common ;
import path ;
import type ;
import targets ;
import generators ;
import "class" : new ;
import os ;

# Make this module into a project.
project.initialize $(__name__) ;
project tar ;

rule init ( tar-binary-filepath ? )
{
    if ! $(tar-binary-filepath)
    {
        if [ os.on-windows ]
        {
            errors.error "To use tar.jam on Windows you must provide the path to a tar program like bsdtar or GNU Win32 tar." ;
        }
        else
        {
            tar-binary-filepath = tar ;
        }
    }
    else if ! [ path.exists $(tar-binary-filepath) ] &&
            ! [ path.glob [ path.programs-path ] : $(tar-binary-filepath:D=) ]
    {
        errors.error Filepath to tar binary \"$(tar-binary-filepath)\" not found. ;
    }

    .tar-binary-filepath = [ path.make $(tar-binary-filepath) ] ;

    if $(.tar-binary-filepath:B) = bsdtar
    {
        .use-bsdtar-syntax = true ;
    }

    #if $(tar.use-bsdtar-syntax) { echo Using bsdtar syntax. ; }
    #else { echo Using GNU tar syntax. ; }

    IMPORT $(__name__) : use-bsdtar-syntax : : use-bsdtar-syntax ;
}

rule use-bsdtar-syntax { return $(.use-bsdtar-syntax) ; }

type.register TBZ2 : tbz2 tar.bz2 ;
type.register TGZ : tgz tar.gz ;
type.register TLZ : tlz tar.lzma ;

# $(.tar-binary-filepath) -cvjf $(<) -T $(<:B)_file_list.txt $(TAR_ARGS)
actions tar.tbz2.create-really
{
    $(.tar-binary-filepath) -cjf $(<) $(TAR_ARGS)
}

actions tar.tgz.create-really
{
    $(.tar-binary-filepath) -czf $(<) $(TAR_ARGS)
}

actions tar.tlz.create-really
{
    $(.tar-binary-filepath) -clf $(<) $(TAR_ARGS)
}

class tar-target-class : basic-target
{
    import regex path type ;

    rule __init__ ( name : project : sources * : requirements *
        : default-build * : usage-requirements * )
    {
        local pwd = [ path.make [ path.pwd ] ] ;
        local anchor = $(pwd) ;
        self.tar-args += -C [ path.native $(anchor) ] ;
        for local s in $(sources)
        {
            local possible-anchor = [ MATCH "^path-anchor:(.*)" : $(s) ] ;
            local possible-exclude = [ MATCH "^exclude:(.*)" : $(s) ] ;

            # TODO: An include option? It's very hard to do portably :(

            if $(possible-anchor)
            {
                local source-path = [ path.root [ path.make $(possible-anchor) ] $(pwd) ] ;
                self.tar-args += -C [ path.relative-to [ path.make $(anchor) ] $(source-path) ] ;
                anchor = [ path.native $(source-path) ] ;
                if [ use-bsdtar-syntax ]
                {
                    self.tar-file-lines += -C ;
                    self.tar-file-lines += $(anchor) ;
                }
                else
                {
                    self.tar-file-lines += -C$(anchor) ;
                }
                anchor = [ path.make $(anchor) ] ;
            }
            else if $(possible-exclude)
            {
                self.tar-args += --exclude \"$(possible-exclude)\" ;
            }
            else
            {
                # move files from main sources to private list that is never virtualized or scanned
                local native-path = [ path.native $(s) ] ;
                local entry = [ GLOB $(native-path:D) : $(native-path:D=) ] ;
                if $(entry) && [ CHECK_IF_FILE $(entry) ]
                {
                    local source-path = [ path.make $(s) ] ;

                    if ! [ path.is-rooted $(source-path) ]
                    {
                        source-path = [ path.root $(source-path) $(pwd) ] ;
                    }

                    #echo Anchor: $(anchor) ;
                    #echo Original path: $(source-path) ;
                    #echo Final path: [ path.relative-to [ path.make $(anchor) ] $(source-path) ] ;
                    #echo ;
                    self.tar-file-lines += [ path.relative-to [ path.make $(anchor) ] $(source-path) ] ;
                    self.files += $(s) ;
                    self.tar-args += [ path.relative-to [ path.make $(anchor) ] $(source-path) ] ;
                }
                #else if ! $(entry)
                #{
                    #non-file-sources += $(s) ;
                #}
                else
                {
                    local source-path = [ path.make $(s) ] ;

                    if ! [ path.is-rooted $(source-path) ]
                    {
                        source-path = [ path.root $(source-path) $(pwd) ] ;
                    }

                    self.directories += $(s) ;
                    self.tar-args += [ path.relative-to [ path.make $(anchor) ] $(source-path) ] ;
                }
            }
        }

        self.tar-args = [ sequence.join $(self.tar-args) : " " ] ;
        #echo tar: $(self.tar-args) ;
        basic-target.__init__ $(name) : $(project) : $(non-file-sources) :
            $(requirements) : $(default-build) : $(usage-requirements) ;
    }

    import utility ;
    rule construct ( name : sources * : property-set )
    {
        #echo $(self.files) ;
        #echo $(self.directories) ;
        #echo $(self.tar-file-lines) ;
        #for local s in $(sources) { echo [ utility.str $(s) ] ; echo ; }

        local action-name ;
        local extension = $(name:B=) ;
        if $(extension) = .bz2 || $(extension) = .tbz2 { action-name = tar.tbz2.create-really ; }
        else if $(extension) = .gz || $(extension) = .tgz { action-name = tar.tgz.create-really ; }
        else if $(extension) = .lzma || $(extension) = .tlz { action-name = tar.tlz.create-really ; }
        else { errors.error Unknown suffix on action ; }

        local NL = "
" ;
        #local tar-file-list = $(self.tar-file-lines:J=$(NL)) ;
        #local f = @($(name:B)_file_list.txt:E=$(tar-file-list)) ;

        local a = [ new action : $(action-name) : $(property-set) ] ;
        local t = [ new file-target $(self.name) exact : [ type.type $(self.name) ] : $(self.project) : $(a) ] ;
        local t = [ virtual-target.register $(t) ] ;
        #echo $(self.name) ;
        local actual-result = [ $(t).actualize ] ;
        ALWAYS $(actual-result) ;
        TAR_ARGS on $(actual-result) = $(self.tar-args) ;
        return [ property-set.empty ] $(t) ;
    }
}

# TODO: surely there's a better way to do this, but damned if I can figure it out
# Typed-targets must have at least one source, so use this jamfile as a decoy
actions quietly tar.noop { }

type.register JAM_DECOY_SOURCE : jam ;
generators.register-standard tar.noop : : JAM_DECOY_SOURCE ;

rule create ( tar-filepath : tar-sources * : tar-requirements * : tar-usage-requirements * )
{
    local project = [ project.current ] ;

    targets.main-target-alternative
        [ new tar-target-class $(tar-filepath) : $(project)
            : [ targets.main-target-sources $(tar-sources) : $(tar-filepath) ]
            : [ targets.main-target-requirements $(tar-requirements) : $(project) ]
            : [ targets.main-target-default-build : $(project) ]
            : [ targets.main-target-usage-requirements $(tar-usage-requirements) : $(project) ] ] ;
}
