import project ;
import path ;
import feature ;
import toolset ;
import targets ;
import type ;
import generators ;
import sequence ;
import "class" : new ;

# Use this feature to pass filemasks to svnrev_max instead of existing files.
feature.feature filemask : : free ;

# Use this feature to generate a jamfile with revision info.
feature.feature jamfile : false true ;

# Make this module into a project.
project.initialize $(__name__) ;

# BUG: source-location should default to the current jamfile's directory,
# but a bug in bjam appears to be making the default the CWD instead whenever
# the project is initialized with a 'using' statement (i.e. "using svnrev_max ;")
project svnrev_max ;

rule init ( boost-root : svnrev-path : requirements * )
{
    if ! $(.initialized)
    {
        .initialized = true ;

        .boost-root = [ path.make $(boost-root) ] ;

        path-constant BOOST_PATH : $(.boost-root) ;
        using ext-boost : 1.39.0 : $(BOOST_PATH) ;

        exe svnrev_max
        : # sources
            $(svnrev-path)/svnrev_max.cpp
            /ext/boost//filesystem
            /ext/boost//regex
            /ext/boost//date_time
            /ext/boost//program_options
        : # requirements
            $(requirements)
        ;
    }
}


# The action has to invoke the tool built in other
# parts of the project. The <bcp> feature is used
# to specify the location of the tool, and the flags
# statement below make the full path to the tool
# available inside the action.
feature.feature svnrev_max : : dependency free ;
toolset.flags svnrev_max.svnrev_max COMMAND <svnrev_max> ;

type.register SVNREV : : HPP ;
type.register SVNREV_AND_JAM : : HPP ;

actions svnrev_max.generate-version-header-action bind COMMAND
{
   $(COMMAND) -v -i -h$(<) $(>) $(ARGS)
}

actions svnrev_max.generate-version-header-and-jam-action bind COMMAND
{
   $(COMMAND) -v -i -h$(<) -j$(<:S=.jam) $(>) $(ARGS)
}

class svnrev-generator : generator
{
    import path property-set sequence ;

    rule svnrev-filter ( source )
    {
        if ! [ MATCH "^(svnrev_max.*)" : [ $(source).name ] ] { return true ; }
    }

    rule generated-targets ( sources + : property-set : project name ? )
    {
        # remove the /svnrev//svnrev hack
        sources = [ sequence.filter svnrev-filter : $(sources) ] ;
        
        local properties = [ $(property-set).raw ] ;
        local svnrev = [ property.select <svnrev_max> : $(properties) ] ;
        local t = [ generator.generated-targets $(sources) $(svnrev:G=)
                            : [ $(property-set).add-raw <source>svnrev.hpp ] : $(project) $(name) ] ;
        local actual-result = [ $(t).actualize ] ;
        # TODO: is ALWAYS appropriate? ALWAYS $(actual-result) ;
        ARGS on $(actual-result) = [ feature.get-values filemask : $(properties) ] ;
        
        return $(t) ;
    }
}

generators.register [ new svnrev-generator svnrev_max.svnrev_max.generate-version-header-action true : : SVNREV ] ;
generators.register [ new svnrev-generator svnrev_max.svnrev_max.generate-version-header-and-jam-action true : : SVNREV_AND_JAM ] ;

.filename = svnrev.hpp ;

rule recursion-filter ( source )
{
    if $(source) != $(.filename) { return true ; }
}

rule generate-version-header ( filename : sources-with-rcs-keywords * : requirements * : usage-requirements * )
{
    .filename = $(filename) ;
    sources-with-rcs-keywords = [ sequence.filter recursion-filter : $(sources-with-rcs-keywords) ] ;
    # HACK: /svnrev_max//svnrev_max is always added so that at least one source is passed
    if <jamfile>true in $(requirements)
    {
        targets.create-typed-target SVNREV_AND_JAM : [ project.current ] :
        $(filename) : /svnrev_max//svnrev_max $(sources-with-rcs-keywords) : $(requirements) <svnrev_max>/svnrev_max//svnrev_max ;
    }
    else
    {
        targets.create-typed-target SVNREV : [ project.current ] :
            $(filename) : /svnrev_max//svnrev_max $(sources-with-rcs-keywords) : $(requirements) <svnrev_max>/svnrev_max//svnrev_max ;
    }
}
