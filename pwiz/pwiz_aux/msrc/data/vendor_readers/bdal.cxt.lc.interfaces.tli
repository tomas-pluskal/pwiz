// Created by Microsoft (R) C/C++ Compiler Version 15.00.30729.01 (a84567c9).
//
// c:\bumbershoot\src\pwiz-src\build\pwiz_aux\msrc\data\vendor_readers\msvc-9.0\release\link-static\runtime-link-static\threading-multi\bdal.cxt.lc.interfaces.tli
//
// Wrapper implementations for Win32 type library BDal.CXt.Lc.Interfaces.tlb
// compiler-generated file created 02/10/09 at 09:49:58 - DO NOT EDIT!

#pragma once

//
// interface ISpectrum wrapper method implementations
//

inline double ISpectrum::GetTime ( ) {
    double _result = 0;
    HRESULT _hr = get_Time(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISpectrum::GetIntensity ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Intensity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISpectrumCollection wrapper method implementations
//

inline long ISpectrumCollection::GetNumberOfSpectra ( ) {
    long _result = 0;
    HRESULT _hr = get_NumberOfSpectra(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ISpectrumPtr ISpectrumCollection::GetItem ( long i ) {
    struct ISpectrum * _result = 0;
    HRESULT _hr = get_Item(i, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISpectrumPtr(_result, false);
}

//
// interface ITraceDeclarationPump wrapper method implementations
//

inline long ITraceDeclarationPump::GetPump ( ) {
    long _result = 0;
    HRESULT _hr = get_Pump(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITraceDataCollection wrapper method implementations
//

inline SAFEARRAY * ITraceDataCollection::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ITraceDataCollection::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITraceDeclaration wrapper method implementations
//

inline long ITraceDeclaration::GetTraceId ( ) {
    long _result = 0;
    HRESULT _hr = get_TraceId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITraceDeclaration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITraceDeclaration::GetInstrument ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Instrument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITraceDeclaration::GetInstrumentId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstrumentId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline enum TraceType ITraceDeclaration::GetType ( ) {
    enum TraceType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum Unit ITraceDeclaration::GetTraceUnit ( ) {
    enum Unit _result;
    HRESULT _hr = get_TraceUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline double ITraceDeclaration::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISpectrumSourceDeclaration wrapper method implementations
//

inline long ISpectrumSourceDeclaration::GetSpectrumCollectionId ( ) {
    long _result = 0;
    HRESULT _hr = get_SpectrumCollectionId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISpectrumSourceDeclaration::GetXAxis ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ISpectrumSourceDeclaration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ISpectrumSourceDeclaration::GetInstrument ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Instrument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ISpectrumSourceDeclaration::GetInstrumentId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstrumentId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline double ISpectrumSourceDeclaration::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum Unit ISpectrumSourceDeclaration::GetXAxisUnit ( ) {
    enum Unit _result;
    HRESULT _hr = get_XAxisUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAnalysis wrapper method implementations
//

inline HRESULT IAnalysis::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline SAFEARRAY * IAnalysis::GetTraceDeclarations ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetTraceDeclarations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ITraceDataCollectionPtr IAnalysis::GetTraceDataCollection ( long TraceId ) {
    struct ITraceDataCollection * _result = 0;
    HRESULT _hr = raw_GetTraceDataCollection(TraceId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITraceDataCollectionPtr(_result, false);
}

inline SAFEARRAY * IAnalysis::GetSpectrumSourceDeclarations ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSpectrumSourceDeclarations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ISpectrumCollectionPtr IAnalysis::GetSpectrumCollection ( long SpectrumCollectionId ) {
    struct ISpectrumCollection * _result = 0;
    HRESULT _hr = raw_GetSpectrumCollection(SpectrumCollectionId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISpectrumCollectionPtr(_result, false);
}

inline SAFEARRAY * IAnalysis::GetSampleInfo ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SampleInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAnalysis::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAnalysisFactory wrapper method implementations
//

inline IAnalysisPtr IAnalysisFactory::Open ( _bstr_t path ) {
    struct IAnalysis * _result = 0;
    HRESULT _hr = raw_Open(path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAnalysisPtr(_result, false);
}

//
// interface ITraceDeclarationColumn wrapper method implementations
//

inline long ITraceDeclarationColumn::GetColumn ( ) {
    long _result = 0;
    HRESULT _hr = get_Column(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITraceDeclarationPumpSolvent wrapper method implementations
//

inline long ITraceDeclarationPumpSolvent::GetSolvent ( ) {
    long _result = 0;
    HRESULT _hr = get_Solvent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}
