//
// cvgen.cpp
//
// 
// Darren Kessner <Darren.Kessner@cshs.org>
//
// Copyright 2007 Spielberg Family Center for Applied Proteomics
//   Cedars-Sinai Medical Center, Los Angeles, California  90048
//   Unauthorized use or reproduction prohibited
//


#include "obo.hpp"
#include "boost/filesystem/path.hpp"
#include "boost/filesystem/fstream.hpp"
#include <iostream>
#include <iomanip>
#include <fstream>
#include <iterator>
#include <algorithm>
#include <map>


using namespace std;
using namespace pwiz::msdata;
namespace bfs = boost::filesystem;


//
// This program selectively parses OBO format controlled vocabulary files 
// and generates C++ code (one hpp file and one cpp file).
//


void writeCopyright(ostream& os, const string& filename)
{
    os << "//\n"
       << "// " << filename << endl
       << "//\n"
          "//\n"
          "// Darren Kessner <Darren.Kessner@cshs.org>\n"
          "//\n"
          "// Copyright 2007 Spielberg Family Center for Applied Proteomics\n"
          "//   Cedars-Sinai Medical Center, Los Angeles, California  90048\n"
          "//   Unauthorized use or reproduction prohibited\n"
          "//\n"
          "// This file was generated by cvgen.\n"
          "//\n\n\n";
}


string includeGuardString(const string& basename)
{
    string includeGuard = basename;
    transform(includeGuard.begin(), includeGuard.end(), includeGuard.begin(), (int(*)(int))toupper);
    return "_" + includeGuard + "_HPP_";
}


void namespaceBegin(ostream& os, const string& name)
{
    os << "namespace pwiz {\n"
       << "namespace msdata {\n\n\n";
}


void namespaceEnd(ostream& os, const string& name)
{
    os << "} // namespace msdata\n"
       << "} // namespace pwiz\n\n\n";
}


inline char toAllowableChar(char a)
{
    return isalnum(a) ? a : '_';
}


string enumName(const string& prefix, const string& name)
{
    string result = name;
    transform(result.begin(), result.end(), result.begin(), toAllowableChar);
    result = prefix + "_" + result;
    return result;
}


string enumName(const Term& term)
{
    return enumName(term.prefix, term.name);
}


size_t enumValue(const Term& term, size_t index)
{
    return term.id + (100000000 * index);
}


void writeHpp(const vector<OBO>& obos, const string& basename, const bfs::path& outputDir)
{
    string filename = basename + ".hpp";
    bfs::path filenameFullPath = outputDir / filename;
    bfs::ofstream os(filenameFullPath, ios::binary);

    writeCopyright(os, filename);

    string includeGuard = includeGuardString(basename);
    os << "#ifndef " << includeGuard << endl
       << "#define " << includeGuard << "\n\n\n"
       << "#include <string>\n"
       << "#include <vector>\n"
       << "\n\n";

    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)
    {
        os << "// [" << obo->filename << "]\n";
        
        for (vector<string>::const_iterator it=obo->header.begin(); it!=obo->header.end(); ++it)
            os << "//   " << *it << endl;

        os << "//\n";
    }
    os << "\n\n";

    namespaceBegin(os, basename);

    os << "/// enumeration of controlled vocabulary (CV) terms, generated from an OBO file\n" 
          "enum CVID\n{\n"
          "    CVID_Unknown = -1";
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
    {
        os << ",\n";
        os << "    " << enumName(*it) << " = " << enumValue(*it, obo-obos.begin());
        
        for (vector<string>::const_iterator syn=it->exactSynonyms.begin(); 
             syn!=it->exactSynonyms.end(); ++syn)
        {
            if (*syn == "peak processing") continue; // TODO remove when psi-ms.obo fixed
            os << ",\n";
            os << "    " << enumName(it->prefix, *syn) << " = " << enumName(*it);
        }
    }
    os << "\n}; // enum CVID\n\n\n"; 

    os << "/// structure for holding CV term info\n" 
          "struct CVInfo\n"
          "{\n"
          "    CVID cvid;\n"
          "    std::string id;\n"      
          "    std::string name;\n"
          "    std::string def;\n"
          "\n"
          "    typedef std::vector<CVID> id_list;\n"
          "    id_list parentsIsA;\n"
          "    id_list parentsPartOf;\n"
          "    std::vector<std::string> exactSynonyms;\n"
          "\n"
          "    CVInfo() : cvid((CVID)-1) {}\n"
          "    const std::string& shortName() const;\n"
          "};\n\n\n";

    os << "/// returns CV term info for the specified CVID\n" 
          "const CVInfo& cvinfo(CVID id);\n\n\n";

    os << "/// returns true iff child IsA parent in the CV\n" 
          "bool cvIsA(CVID child, CVID parent);\n\n\n";

    os << "/// returns vector of all valid CVIDs\n" 
          "const std::vector<CVID>& cvids();\n\n\n";

    namespaceEnd(os, basename);

    os << "#endif // " << includeGuard << "\n\n\n";
}


void writeCpp(const vector<OBO>& obos, const string& basename, const bfs::path& outputDir)
{
    string filename = basename + ".cpp";
    bfs::path filenameFullPath = outputDir / filename;
    bfs::ofstream os(filenameFullPath, ios::binary);

    writeCopyright(os, filename);

    os << "#include \"" << basename << ".hpp\"\n"
       << "#include <map>\n"
       << "\n\n";

    namespaceBegin(os, basename);

    os << "using namespace std;\n\n\n";

    os << "namespace {\n\n\n";

    os << "struct TermInfo\n"
          "{\n"
          "    CVID cvid;\n"
          "    const char* id;\n"
          "    const char* name;\n"
          "    const char* def;\n"
          "};\n\n\n";

    os << "const TermInfo termInfos_[] =\n{\n";
    os << "    {CVID_Unknown, \"??:0000000\", \"CVID_Unknown\", \"CVID_Unknown\"},\n";
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
        os << "    {" << enumName(*it) << ", "
           << "\"" << it->prefix << ":" << setw(7) << setfill('0') << it->id << "\", "
           << "\"" << it->name << "\", " 
           << "\"" << it->def << "\""
           << "},\n";
    os << "}; // termInfos_\n\n\n";

    os << "const unsigned int termInfosSize_ = sizeof(termInfos_)/sizeof(TermInfo);\n\n\n";

    os << "struct CVIDPair\n"
          "{\n"
          "    CVID first;\n"
          "    CVID second;\n"
          "};\n\n\n";

    // create a term map for each OBO

    vector< map<Term::id_type, const Term*> > termMaps(obos.size());
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)    
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
        termMaps[obo-obos.begin()][it->id] = &*it;

    os << "CVIDPair relationsIsA_[] =\n{\n";
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)    
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
    for (Term::id_list::const_iterator jt=it->parentsIsA.begin(); jt!=it->parentsIsA.end(); ++jt)
        os << "    {" << enumName(*it) << ", " 
           << enumName(*termMaps[obo-obos.begin()][*jt]) << "},\n";
    os << "}; // relationsIsA_\n\n\n";

    os << "const unsigned int relationsIsASize_ = sizeof(relationsIsA_)/sizeof(CVIDPair);\n\n\n";

    os << "CVIDPair relationsPartOf_[] =\n{\n";
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)    
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
    for (Term::id_list::const_iterator jt=it->parentsPartOf.begin(); jt!=it->parentsPartOf.end(); ++jt)
        os << "    {" << enumName(*it) << ", " 
           << enumName(*termMaps[obo-obos.begin()][*jt]) << "},\n";
    os << "}; // relationsPartOf_\n\n\n";

    os << "const unsigned int relationsPartOfSize_ = sizeof(relationsPartOf_)/sizeof(CVIDPair);\n\n\n";

    os << "struct CVIDStringPair\n"
          "{\n"
          "    CVID first;\n"
          "    const char* second;\n"
          "};\n\n\n";

    os << "CVIDStringPair relationsExactSynonym_[] =\n"
       << "{\n"
       << "    {CVID_Unknown, \"Unknown\"},\n";
    for (vector<OBO>::const_iterator obo=obos.begin(); obo!=obos.end(); ++obo)    
    for (vector<Term>::const_iterator it=obo->terms.begin(); it!=obo->terms.end(); ++it)
    for (vector<string>::const_iterator jt=it->exactSynonyms.begin(); jt!=it->exactSynonyms.end(); ++jt)
        os << "    {" << enumName(*it) << ", " 
           << "\"" << *jt << "\"" << "},\n";
    os << "}; // relationsExactSynonym_\n\n\n";

    os << "const unsigned int relationsExactSynonymSize_ = sizeof(relationsExactSynonym_)/sizeof(CVIDStringPair);\n\n\n";

    os << "bool initialized_ = false;\n"
          "map<CVID,CVInfo> infoMap_;\n"
          "vector<CVID> cvids_;\n"
          "\n\n";

    os << "void initialize()\n"
          "{\n"
          "    for (const TermInfo* it=termInfos_; it!=termInfos_+termInfosSize_; ++it)\n" 
          "    {\n"
          "        CVInfo temp;\n"
          "        temp.cvid = it->cvid;\n"
          "        temp.id = it->id;\n"
          "        temp.name = it->name;\n"
          "        temp.def = it->def;\n"
          "        infoMap_[temp.cvid] = temp;\n"
          "        cvids_.push_back(it->cvid);\n"
          "\n"
          "    }\n"
          "\n"
          "    for (const CVIDPair* it=relationsIsA_; it!=relationsIsA_+relationsIsASize_; ++it)\n"
          "        infoMap_[it->first].parentsIsA.push_back(it->second);\n"
          "\n"
          "    for (const CVIDPair* it=relationsPartOf_; it!=relationsPartOf_+relationsPartOfSize_; ++it)\n"
          "        infoMap_[it->first].parentsPartOf.push_back(it->second);\n"
          "\n"
          "    for (const CVIDStringPair* it=relationsExactSynonym_; it!=relationsExactSynonym_+relationsExactSynonymSize_; ++it)\n"
          "        infoMap_[it->first].exactSynonyms.push_back(it->second);\n"
          "\n"
          "    initialized_ = true;\n"
          "}\n\n\n";

    os << "} // namespace\n\n\n";

    os << "const string& CVInfo::shortName() const\n"
          "{\n"
          "    const string* result = &name;\n"
          "    for (vector<string>::const_iterator it=exactSynonyms.begin(); it!=exactSynonyms.end(); ++it)\n"
          "        if (result->size() > it->size())\n"
          "            result = &*it;\n"
          "    return *result;\n"
          "}\n\n\n";

    os << "const CVInfo& cvinfo(CVID id)\n"
          "{\n"
          "   if (!initialized_) initialize();\n"
          "   return infoMap_[id];\n"
          "}\n\n\n";

    os << "bool cvIsA(CVID child, CVID parent)\n"
          "{\n"
          "    if (child == parent) return true;\n"
          "    const CVInfo& info = cvinfo(child);\n"
          "    for (CVInfo::id_list::const_iterator it=info.parentsIsA.begin(); it!=info.parentsIsA.end(); ++it)\n"
          "        if (cvIsA(*it,parent)) return true;\n"
          "    return false;\n"
          "}\n\n\n";

    os << "const vector<CVID>& cvids()\n"
          "{\n"
          "   if (!initialized_) initialize();\n"
          "   return cvids_;\n"
          "}\n\n\n";

    namespaceEnd(os, basename);
}


void generateFiles(const vector<OBO>& obos, const string& basename, const bfs::path& outputDir)
{
    writeHpp(obos, basename, outputDir);
    writeCpp(obos, basename, outputDir);
}


int main(int argc, char* argv[])
{
    if (argc < 2)
    {
        cout << "Usage: cvgen file.obo [...]\n";
        cout << "Parse input file(s) and output cv.hpp and cv.cpp.\n";
        return 1;
    }

    try
    {
        bfs::path exeDir(bfs::path(argv[0]).branch_path());

        vector<OBO> obos;
        for (int i=1; i<argc; i++)
            obos.push_back(OBO(argv[i]));

        generateFiles(obos, "cv", exeDir);

        return 0;
    }
    catch (exception& e)
    {
        cerr << "Caught exception: " << e.what() << endl;
    }
    catch (...)
    {
        cerr << "Caught unknown exception.\n";
    }

    return 1; 
}

