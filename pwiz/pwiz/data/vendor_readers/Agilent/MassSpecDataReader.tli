// Created by Microsoft (R) C/C++ Compiler Version 15.00.30729.01 (d898beac).
//
// c:\bumbershoot\src\pwiz-src\build\pwiz\data\vendor_readers\agilent\msvc-9.0\release\link-static\threading-multi\massspecdatareader.tli
//
// Wrapper implementations for Win32 type library MassSpecDataReader.tlb
// compiler-generated file created 05/19/09 at 10:02:20 - DO NOT EDIT!

#pragma once

//
// interface IDeviceInfo wrapper method implementations
//

inline _bstr_t IDeviceInfo::GetDeviceName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DeviceName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IDeviceInfo::PutDeviceName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_DeviceName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDeviceInfo::GetOrdinalNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_OrdinalNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDeviceInfo::PutOrdinalNumber ( long pRetVal ) {
    HRESULT _hr = put_OrdinalNumber(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline enum DeviceType IDeviceInfo::GetDeviceType ( ) {
    enum DeviceType _result;
    HRESULT _hr = get_DeviceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDeviceInfo::PutDeviceType ( enum DeviceType pRetVal ) {
    HRESULT _hr = put_DeviceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISignalInfo wrapper method implementations
//

inline IDeviceInfoPtr ISignalInfo::GetDeviceInformation ( ) {
    struct IDeviceInfo * _result = 0;
    HRESULT _hr = get_DeviceInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDeviceInfoPtr(_result, false);
}

inline void ISignalInfo::PutRefDeviceInformation ( struct IDeviceInfo * pRetVal ) {
    HRESULT _hr = putref_DeviceInformation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ISignalInfo::GetSignalName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SignalName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void ISignalInfo::PutSignalName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SignalName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface INonmsDataReader wrapper method implementations
//

inline SAFEARRAY * INonmsDataReader::GetNonmsDevices ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNonmsDevices(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * INonmsDataReader::GetSignalInfo ( struct IDeviceInfo * dev, enum StoredDataType type ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSignalInfo(dev, type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline BDA::IBDAChromDataPtr INonmsDataReader::GetSignal ( struct ISignalInfo * sig ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetSignal(sig, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr INonmsDataReader::GetTWC ( struct IDeviceInfo * dev ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetTWC(dev, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr INonmsDataReader::GetEWC ( struct IDeviceInfo * dev, struct IRange * signal, struct IRange * reference ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetEWC(dev, signal, reference, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline SAFEARRAY * INonmsDataReader::GetUVSpectrum ( struct IDeviceInfo * dev, struct IRange * scanRange ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetUVSpectrum(dev, scanRange, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IMsdrChargeStateAssignmentFilter wrapper method implementations
//

inline double IMsdrChargeStateAssignmentFilter::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrChargeStateAssignmentFilter::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL IMsdrChargeStateAssignmentFilter::GetLimitMaxChargeState ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LimitMaxChargeState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrChargeStateAssignmentFilter::PutLimitMaxChargeState ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_LimitMaxChargeState(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IMsdrChargeStateAssignmentFilter::GetMaximumChargeState ( ) {
    long _result = 0;
    HRESULT _hr = get_MaximumChargeState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrChargeStateAssignmentFilter::PutMaximumChargeState ( long pRetVal ) {
    HRESULT _hr = put_MaximumChargeState(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline double IMsdrChargeStateAssignmentFilter::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrChargeStateAssignmentFilter::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL IMsdrChargeStateAssignmentFilter::GetRequirePeptideLikeAbundanceProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RequirePeptideLikeAbundanceProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrChargeStateAssignmentFilter::PutRequirePeptideLikeAbundanceProfile ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_RequirePeptideLikeAbundanceProfile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IMsdrPeakFilter wrapper method implementations
//

inline double IMsdrPeakFilter::GetRelativeThreshold ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrPeakFilter::PutRelativeThreshold ( double pRetVal ) {
    HRESULT _hr = put_RelativeThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline double IMsdrPeakFilter::GetAbsoluteThreshold ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrPeakFilter::PutAbsoluteThreshold ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IMsdrPeakFilter::GetMaxNumPeaks ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxNumPeaks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMsdrPeakFilter::PutMaxNumPeaks ( long pRetVal ) {
    HRESULT _hr = put_MaxNumPeaks(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IMsdrDataReader wrapper method implementations
//

inline VARIANT_BOOL IMsdrDataReader::OpenDataFile ( _bstr_t fileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OpenDataFile(fileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IMsdrDataReader::CloseDataFile ( ) {
    HRESULT _hr = raw_CloseDataFile();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IMsdrDataReader::RefreshDataFile ( VARIANT_BOOL * isNewDataPresent ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RefreshDataFile(isNewDataPresent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline BDA::IBDAFileInformationPtr IMsdrDataReader::GetFileInformation ( ) {
    struct BDA::IBDAFileInformation * _result = 0;
    HRESULT _hr = get_FileInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAFileInformationPtr(_result, false);
}

inline BDA::IBDAMSScanFileInformationPtr IMsdrDataReader::GetMSScanFileInformation ( ) {
    struct BDA::IBDAMSScanFileInformation * _result = 0;
    HRESULT _hr = get_MSScanFileInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAMSScanFileInformationPtr(_result, false);
}

inline BDA::IBDAMSScanFileInformationPtr IMsdrDataReader::GetMSScanInformation ( double retentionTime ) {
    struct BDA::IBDAMSScanFileInformation * _result = 0;
    HRESULT _hr = raw_GetMSScanInformation(retentionTime, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAMSScanFileInformationPtr(_result, false);
}

inline BDA::IBDAChromDataPtr IMsdrDataReader::GetTIC ( ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetTIC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr IMsdrDataReader::GetTIC_2 ( double startTime, double endTime, enum MSScanType scanType, enum IonPolarity ionPloarity, enum IonizationMode ionMode ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetTIC_2(startTime, endTime, scanType, ionPloarity, ionMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr IMsdrDataReader::GetBPC ( ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetBPC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr IMsdrDataReader::GetBPC_2 ( double startTime, double endTime, enum MSScanType scanType, enum IonPolarity ionPolarity, enum IonizationMode ionMode ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetBPC_2(startTime, endTime, scanType, ionPolarity, ionMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline BDA::IBDAChromDataPtr IMsdrDataReader::GetEIC ( SAFEARRAY * massOfInterest, enum MSScanType scanType, enum IonPolarity ionPolarity, enum IonizationMode ionMode ) {
    struct BDA::IBDAChromData * _result = 0;
    HRESULT _hr = raw_GetEIC(massOfInterest, scanType, ionPolarity, ionMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAChromDataPtr(_result, false);
}

inline SAFEARRAY * IMsdrDataReader::GetEICForEachMass ( SAFEARRAY * massOfInterest, enum MSScanType scanType, enum IonPolarity ionPolarity, enum IonizationMode ionMode ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetEICForEachMass(massOfInterest, scanType, ionPolarity, ionMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * IMsdrDataReader::GetChromatogram ( struct BDA::IBDAChromFilter * chromFilter ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetChromatogram(chromFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline BDA::IBDASpecDataPtr IMsdrDataReader::GetSpectrum ( double retentionTime, enum MSScanType scanType, enum IonPolarity ionPloarity, enum IonizationMode ionMode, struct IMsdrPeakFilter * peakFilter ) {
    struct BDA::IBDASpecData * _result = 0;
    HRESULT _hr = raw_GetSpectrum(retentionTime, scanType, ionPloarity, ionMode, peakFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDASpecDataPtr(_result, false);
}

inline BDA::IBDASpecDataPtr IMsdrDataReader::GetSpectrum_2 ( struct IRange * rtRange, struct IMsdrPeakFilter * peakFilter ) {
    struct BDA::IBDASpecData * _result = 0;
    HRESULT _hr = raw_GetSpectrum_2(rtRange, peakFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDASpecDataPtr(_result, false);
}

inline BDA::IBDASpecDataPtr IMsdrDataReader::GetSpectrum_3 ( SAFEARRAY * rtRanges, struct IMsdrPeakFilter * peakFilter ) {
    struct BDA::IBDASpecData * _result = 0;
    HRESULT _hr = raw_GetSpectrum_3(rtRanges, peakFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDASpecDataPtr(_result, false);
}

inline SAFEARRAY * IMsdrDataReader::GetSpectrum_4 ( struct BDA::IBDASpecFilter * specFilter, struct IMsdrPeakFilter * peakFilter ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSpectrum_4(specFilter, peakFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * IMsdrDataReader::GetSpectrum_5 ( struct BDA::IBDASpecFilter * specFilter ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSpectrum_5(specFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline BDA::IBDASpecDataPtr IMsdrDataReader::GetSpectrum_6 ( long rowNumber, struct IMsdrPeakFilter * peakMSFilter, struct IMsdrPeakFilter * peakMSMSFilter ) {
    struct BDA::IBDASpecData * _result = 0;
    HRESULT _hr = raw_GetSpectrum_6(rowNumber, peakMSFilter, peakMSMSFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDASpecDataPtr(_result, false);
}

inline BDA::IBDASpecDataPtr IMsdrDataReader::GetSpectrum_7 ( double retentionTime, enum MSScanType scanType, enum IonPolarity ionPolarity, enum IonizationMode ionMode, struct IMsdrPeakFilter * peakFilter, VARIANT_BOOL peakFilterOnCentroid ) {
    struct BDA::IBDASpecData * _result = 0;
    HRESULT _hr = raw_GetSpectrum_7(retentionTime, scanType, ionPolarity, ionMode, peakFilter, peakFilterOnCentroid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDASpecDataPtr(_result, false);
}

inline HRESULT IMsdrDataReader::Deisotope ( struct BDA::IBDASpecData * spectrum, struct IMsdrChargeStateAssignmentFilter * csaFilter ) {
    HRESULT _hr = raw_Deisotope(spectrum, csaFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IMsdrDataReader::GetSchemaDefaultDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SchemaDefaultDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IMsdrDataReader::PutSchemaDefaultDirectory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SchemaDefaultDirectory(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline BDA::IBDAActualsPtr IMsdrDataReader::GetActualsInformation ( ) {
    struct BDA::IBDAActuals * _result = 0;
    HRESULT _hr = get_ActualsInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BDA::IBDAActualsPtr(_result, false);
}

inline _bstr_t IMsdrDataReader::GetVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}
