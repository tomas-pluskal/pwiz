#
# $Id$
#
#
# Original author: Darren Kessner <darren@proteowizard.org>
#
# Copyright 2008 Spielberg Family Center for Applied Proteomics
#   Cedars-Sinai Medical Center, Los Angeles, California  90048
#
# Licensed under the Apache License, Version 2.0 (the "License"); 
# you may not use this file except in compliance with the License. 
# You may obtain a copy of the License at 
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software 
# distributed under the License is distributed on an "AS IS" BASIS, 
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
# See the License for the specific language governing permissions and 
# limitations under the License.

path-constant PWIZ_ROOT_PATH : . ;

local default_boost_src = "./libraries/boost_1_39_0" ;
local boost_src = [ MATCH --boost-src=(.*) : [ modules.peek : ARGV ] ] ;
boost_src ?= $(default_boost_src) ; # set default path in absence of command-line path

local default_zlib_src = "./libraries/zlib-1.2.3" ;
local zlib_src = [ MATCH --zlib-src=(.*) : [ modules.peek : ARGV ] ] ;
zlib_src ?= $(default_zlib_src) ; # set default path in absence of command-line path

import testing ; # needed to enable unit-test rule
import feature ; # needed for install rules

################################
## Targets and Related Options #
################################
#   build                   Build ProteoWizard applications
#   =====
#   --boost-src=<DIR>       Find Boost source distribution here.
#                           Default: "./libraries/boost_1_39_0"
#
#   --zlib-src=<DIR>        Find zlib source distribution here.
#                           Default: "./libraries/zlib-1.23.0"
project pwiz 
    : requirements 
        <include>$(PWIZ_ROOT_PATH)
        <include>$(PWIZ_ROOT_PATH)/libraries/boost_aux
        <include>$(boost_src)
        <include>$(zlib_src)

        <toolset>gcc,<link>shared:<runtime-link>shared

        # using pwiz_wifffile (compiled with /clr) requires the shared runtime,
        # regardless of how pwiz_wifffile is linked
        <toolset>msvc:<runtime-link>shared

        # special msvc hacks
        <toolset>msvc:<define>WIN32                     # windows
        <toolset>msvc:<define>_CRT_SECURE_NO_DEPRECATE  # don't deprecate the standard library 
        <toolset>msvc:<define>_SCL_SECURE_NO_DEPRECATE  # don't deprecate the standard library 
        <toolset>msvc:<define>_SECURE_SCL_THROWS=1      # checked iterators throw instead of crash  
        <toolset>msvc:<define>_USE_MATH_DEFINES         # for M_PI in <cmath>
        <toolset>msvc:<cxxflags>/wd4100                 # warning: unreferenced formal parameter
        <toolset>msvc:<cxxflags>/wd4512                 # warning: assignment operator could not be generated
        <toolset>msvc:<cxxflags>/wd4127                 # warning: conditional expression is constant (boost::lexical_cast)
        <toolset>msvc:<cxxflags>/wd4701                 # warning: potentially uninitialized local variable 'result' used (boost::lexical_cast, debug)
        <toolset>msvc:<cxxflags>/wd4245                 # warning: conversion from 'type1' to 'type2', signed/unsigned mismatch (boost/filesystem/convenience.hpp)
        <toolset>msvc:<cxxflags>/wd4251                 # warning: class needs to have dll-interface to be used by clients of class
        <toolset>msvc:<cxxflags>/wd4267	                # warning: conversion from 'type1' to 'type2', possible loss of data (boost::lexical_cast)
        <toolset>msvc:<cxxflags>/wd4244                 # warning: conversion from 'int' to 'unsigned short', possible loss of data (boost/date_time/microsec_time_clock.hpp)
        <toolset>msvc:<cxxflags>/wd4275                 # warning: non dll-interface class 'base' used as base for dll-interface class 'derived'
        <toolset>msvc:<cxxflags>/wd4702                 # warning: unreachable code (boost::lexical_cast)

        # special gcc hack - Cygwin gcc 3.4.4, Ubuntu gcc 4.1.2 
        # warning: '__cur' might be used uninitialized in this function 
        <toolset>gcc:<cxxflags>-Wno-uninitialized   

        # special Cygwin gcc-3.4.4 hack
        # linker "multiple definition" error on inclusion of boost-1.34.1 filesystem headers  
        <toolset>gcc-3.4.4:<linkflags>-Wl,--allow-multiple-definition
        <toolset>gcc-mingw-3.4.5:<linkflags>-Wl,--allow-multiple-definition

        # allow "long long" even with -pedantic
        <toolset>gcc:<cxxflags>-Wno-long-long
        <toolset>darwin:<cxxflags>-Wno-long-long

        # don't call 'strip' -- causes 'Bus error' in some cases
        #  e.g. find_if with inline predicate
        <toolset>darwin:<debug-symbols>on
        
        # use of boost::thread requires multithreaded runtime
        <threading>multi

    : build-dir build
    : usage-requirements
        <include>.
    : default-build
        release
        <link>static
        <runtime-link>static
        #<warnings-as-errors>on
        <warnings>all
        <threading>multi
    ;


# define script for decompressing vendor-specific test data (on any platform)
if [ modules.peek : NT ]
{
    path-constant UNTAR_TEST_DATA_SCRIPT : "$(PWIZ_ROOT_PATH)/scripts/test/untar_test_data.bat" ;
}
else if [ modules.peek : UNIX ]
{
    path-constant UNTAR_TEST_DATA_SCRIPT : "$(PWIZ_ROOT_PATH)/scripts/test/untar_test_data.sh" ;
}


# external library declarations

lib pthread 
    : # sources
    : # requirements
        <name>pthread  
        <link>shared
        <toolset>gcc:<linkflags>-pthread # sometimes segfault without this -- dk
    : # default-build
    : # usage-requirements
        <toolset>gcc:<linkflags>-pthread # sometimes segfault without this -- dk
    ;

lib jpeg png z : : <threading>multi ;
lib gd : jpeg png z : <name>gd <threading>multi ;
lib gd : : <toolset>msvc <name>bgd <search>$(PWIZ_ROOT_PATH)/libraries : : <include>$(PWIZ_ROOT_PATH)/libraries/gd-2.0.33 ;

lib fftw3 : : <threading>multi <search>$(PWIZ_ROOT_PATH)/libraries/fftw-3.1.2/.libs : : <include>$(PWIZ_ROOT_PATH)/libraries/fftw-3.1.2/api ;
lib fftw3 : : <threading>multi <toolset>msvc <name>libfftw3-3 <search>$(PWIZ_ROOT_PATH)/libraries : : <include>$(PWIZ_ROOT_PATH)/libraries/fftw-3.1.2/api ;

local .boost-build-file = [ modules.peek : .boost-build-file ] ;
tmp = [ modules.peek : BOOST_BUILD_PATH ] ;
tmp += $(PWIZ_ROOT_PATH)/pwiz $(PWIZ_ROOT_PATH)/libraries ;
modules.poke : BOOST_BUILD_PATH : $(tmp) ;

if [ modules.peek : NT ]
{
    if $(boost_src) = $(default_boost_src)
    {
        SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_boost.bat $(PWIZ_ROOT_PATH)" : no-output ;
    }

    if $(zlib_src) = $(default_zlib_src)
    {
        SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_zlib.bat $(PWIZ_ROOT_PATH)" : no-output ;
    }

    SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_gd.bat $(PWIZ_ROOT_PATH)" : no-output ;
# TODO: warn about GPL? ... SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_fftw.bat $(PWIZ_ROOT_PATH)" : no-output ;
}
else if [ modules.peek : UNIX ]
{
    if $(boost_src) = $(default_boost_src)
    {
        SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_boost.sh $(PWIZ_ROOT_PATH)" : no-output ;
    }

    if $(zlib_src) = $(default_zlib_src)
    {
        SHELL "$(PWIZ_ROOT_PATH)/libraries/untar_zlib.sh $(PWIZ_ROOT_PATH)" : no-output ;
    }
}

path-constant BOOST_SOURCE : $(boost_src) ;
path-constant ZLIB_SOURCE : $(zlib_src) ;

using ext-boost : 1.39.0 : $(BOOST_SOURCE) : <zlib-src-location>$(ZLIB_SOURCE) ;


rule project-exists ( project-path )
{
    if [ path.exists $(project-path) ] &&
       [ path.glob $(project-path) : [Jj]amroot.jam [Jj]amfile.jam [Jj]amroot [Jj]amfile ]
    {
        return true ;
    }
    else
    {
        return ;
    }
}

# to make subsetting the source tree much easier,
# use this rule to test that a sub-project path exists before building it
rule build-project-if-exists ( project-path )
{
    local project = [ project.current ] ;
    local p = [ path.join [ $(project).location ] $(project-path) ] ;
    if [ project-exists $(p) ]
    {
        local attributes = [ project.attributes [ $(project).name ] ] ;
        local now = [ $(attributes).get projects-to-build ] ;
        $(attributes).set projects-to-build : $(now) $(project-path) ;
    }
}


# build/install

build-project-if-exists pwiz ;
build-project-if-exists pwiz_aux ;
build-project-if-exists pwiz_tools ;
build-project-if-exists libraries ;


rule install-location ( properties * )
{
    local toolsets = [ feature.get-values <toolset> : $(properties) ] ;
    local variants = [ feature.get-values <variant> : $(properties) ] ;
    return <location>build/$(toolsets[1])-$(variants[1]) ;
}

rule install-vendor-api-dependencies ( properties * )
{
    local location = [ install-location $(properties) ] ;
    local dependencies ;
    if <toolset>msvc in $(properties)
    {
        if [ path.exists pwiz/utility/vendor_api/thermo ] { dependencies += <dependency>pwiz/utility/vendor_api/thermo//install_pwiz_vendor_api_thermo/$(location) ; }
        if [ path.exists pwiz/utility/vendor_api/Agilent ] { dependencies += <dependency>pwiz/utility/vendor_api/Agilent//install_pwiz_vendor_api_agilent/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/ABI ] { dependencies += <dependency>pwiz_aux/msrc/utility/vendor_api/ABI//install_pwiz_vendor_api_abi/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Bruker ] { dependencies += <dependency>pwiz_aux/msrc/utility/vendor_api/Bruker//install_pwiz_vendor_api_bruker/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Waters ] { dependencies += <dependency>pwiz_aux/msrc/utility/vendor_api/Waters//install_pwiz_vendor_api_waters/$(location) ; }
    }
    return $(dependencies) ;
}


install executables
    : pwiz_tools/commandline
      pwiz_tools/sld//sldout
      pwiz_tools/examples
    : <install-type>EXE
      <conditional>@install-location
      <conditional>@install-vendor-api-dependencies
    ;


install bgddll
    : libraries/bgd.dll
    : <conditional>@install-location
      <toolset>gcc:<build>no
      <toolset>darwin:<build>no
    ;


install package_docs
    : doc/package/readme.txt
    : <conditional>@install-location
    ;


# predicate for use as a <conditional> requirement of targets that must only build with MSVC
rule msvc-requirement ( properties * )
{
    if ! <toolset>msvc in $(properties) { return <build>no ; }
}



# any source tree can build binary tarballs

import os ;
import path ;
import common ;
import property-set ;
import sequence ;
import tar ;

if [ os.on-windows ]
{
  using tar : bsdtar.exe ;
}
else
{
  using tar ;
}

.common-location = $(PWIZ_ROOT_PATH)/build ;

rule binary-tarball-requirements ( properties * )
{
    local toolsets = [ feature.get-values <toolset> : $(properties) ] ;
    local variants = [ feature.get-values <variant> : $(properties) ] ;
    local location = $(.common-location)/$(toolsets[1])-$(variants[1]) ;
    local non-redistributables =
        *MSFileReader.XRawfile2.dll *fregistry.dll *fileio.dll                          # Thermo API
        *ABSciex.DataAccess.WiffFileDataReader.dll *Clear?ore*.dll *rscoree.dll         # ABI API
        *DACServer.dll *genutil.dll *raw.dll *RawCsm.dll *Security*.dll *MetaGD32.dll ; # Waters API
    non-redistributables = [ sequence.join $(non-redistributables) : "&&exclude:" ] ;
    local result = <tar-source>path-anchor:$(location)&&exclude:$(non-redistributables)&&$(location) ;
    local name = [ common.format-name <base> <property:target-os> <toolset> <threading> <runtime> -1.6
                                      : pwiz-bin : TBZ2 : [ property-set.create $(properties) ] ] ;
    result += <name>$(name) ;
    return $(result) ;
}

tar.create pwiz-bin.tar.bz2
  : # sources are handled by the conditional

  : # requirements
    <conditional>@binary-tarball-requirements
    <location>$(.common-location)
    <dependency>executables
  ;


# full source trees automatically build source tarballs

if ! [ path.exists $(PWIZ_ROOT_PATH)/SUBSET ]
{

import bcp ;
using bcp : $(BOOST_SOURCE) : <location>$(.common-location)/bcp ;

path-constant BOOST_SUBSET_PATH : $(.common-location)/boost-subset ;

bcp.copy-boost-dependencies copy_boost_subset
  : # sources

    # scan all source files for boost dependencies
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz_aux : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz_tools : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_ROOT_PATH)/libraries/boost_aux : *.cpp *.hpp ]

    # scan all targets and their dependencies
    $(PWIZ_ROOT_PATH)/pwiz_tools/commandline//mstools

  : # requirements
    <location>$(BOOST_SUBSET_PATH)/boost_1_39_0
  ;


tar.create boost_1_39_0.tar.bz2
  : # sources

      path-anchor:$(BOOST_SUBSET_PATH)
      $(BOOST_SUBSET_PATH)/boost_1_39_0

      path-anchor:$(PWIZ_ROOT_PATH)/libraries
      $(PWIZ_ROOT_PATH)/libraries/boost_1_39_0/tools/build
      $(PWIZ_ROOT_PATH)/libraries/boost_1_39_0/tools/jam

  : # requirements
    <location>$(BOOST_SUBSET_PATH)/libraries
    <dependency>copy_boost_subset
  ;

.exclusion-list =
  exclude:.svn
  exclude:*.bak
  exclude:cvgen*.exe
  exclude:svnrev.exe
  exclude:svnrev.hpp
  exclude:Reader_*_Test.data
  exclude:bin exclude:obj # C#.NET intermediate directories
  exclude:tar.excluded # a place to put any files in these directories that shouldn't be tarballed
;

# the SUBSET file acts as flag so that building a subset tarball doesn't build a source tarball
make SUBSET : : @make_SUBSET : <location>$(.common-location) ;
actions make_SUBSET
{
@($(STDOUT):E=
This source tree is a subset of the full pwiz source tree.
) > "$(<)"
}

.common-sources =
  $(PWIZ_ROOT_PATH)/Jamroot.jam
  $(PWIZ_ROOT_PATH)/NOTICE
  $(PWIZ_ROOT_PATH)/LICENSE
  $(PWIZ_ROOT_PATH)/quickbuild.bat
  $(PWIZ_ROOT_PATH)/quickbuild.sh
  $(PWIZ_ROOT_PATH)/clean.bat
  $(PWIZ_ROOT_PATH)/clean.sh

  $(PWIZ_ROOT_PATH)/doc
  $(PWIZ_ROOT_PATH)/example_data
  $(PWIZ_ROOT_PATH)/libraries/boost-build.tar.bz2
  $(PWIZ_ROOT_PATH)/libraries/boost_aux
  [ path.glob $(PWIZ_ROOT_PATH)/libraries : *.bat *.sh *.jam *.dll *.lib *.exe *.cpp gd*.tar.bz2 zlib*.tar.bz2 ]

  path-anchor:$(PWIZ_ROOT_PATH)/build
  $(PWIZ_ROOT_PATH)/build/SUBSET

  # include the bcp'd boost tarball as if it was really located at "libraries/boost_*.tar.bz2"
  path-anchor:$(BOOST_SUBSET_PATH)
  $(BOOST_SUBSET_PATH)/libraries
;

tar.create pwiz-src.tar.bz2
  : # sources

    path-anchor:$(PWIZ_ROOT_PATH)

    $(.exclusion-list)

    $(PWIZ_ROOT_PATH)/pwiz
    $(PWIZ_ROOT_PATH)/pwiz_aux
    $(PWIZ_ROOT_PATH)/pwiz_tools
    $(PWIZ_ROOT_PATH)/scripts

    $(.common-sources)

  : # requirements
    <location>$(.common-location)
    <dependency>boost_1_39_0.tar.bz2
  ;

tar.create pwiz-src-without-vendor-support.tar.bz2
  : # sources

    path-anchor:$(PWIZ_ROOT_PATH)

    $(.exclusion-list)
    exclude:vendor_readers/*/*.data.tar.bz2
    exclude:vendor_readers/*/*.bat
    exclude:vendor_api

    $(PWIZ_ROOT_PATH)/pwiz
    $(PWIZ_ROOT_PATH)/pwiz_aux
    $(PWIZ_ROOT_PATH)/pwiz_tools
    $(PWIZ_ROOT_PATH)/scripts

    $(.common-sources)

  : # requirements
    <location>$(.common-location)
    <dependency>boost_1_39_0.tar.bz2
  ;

} # if SUBSET
